[
  {
    "question": "Given the following Python code, what will be printed if the element with the ID 'submit-btn' is found and enabled on the page?",
    "code_snippet": "from selenium.webdriver.common.by import By\n\ntry:\n    button = driver.find_element(By.ID, 'submit-btn')\n    if button.is_enabled():\n        print('Button is ready')\n    else:\n        print('Button is not interactable')\nexcept:\n    print('Button not found')",
    "options": [
      "Button is ready",
      "Button is not interactable",
      "Button not found",
      "The code will raise an exception"
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "When the element is found and enabled, the condition button.is_enabled() evaluates to True, executing the print statement 'Button is ready'. The code only prints the other messages if the element is disabled or not found."
  },
  {
    "question": "Which line of Python code correctly initializes a WebDriverWait instance with a 10-second timeout?",
    "options": [
      "wait = WebDriverWait(10, driver)",
      "wait = WebDriverWait(driver, 10)",
      "wait = driver.wait(10)",
      "wait = WebDriverWait.create(driver, 10)"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "WebDriverWait(driver, 10) correctly initializes an explicit wait with a 10-second timeout, where driver is passed first."
  },
  {
    "question": "In Selenium, what is the primary purpose of the `By` class?",
    "options": [
      "To perform browser actions like click() and send_keys()",
      "To manage browser windows and tabs",
      "To provide mechanisms for locating elements on a page (e.g., by ID, Name, XPath)",
      "To store test data"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The By class defines locator strategies (By.ID, By.NAME, By.XPATH, By.CSS_SELECTOR, etc.) that tell Selenium how to find elements in the DOM. It doesn't perform actions, manage windows, or store data."
  },
  {
    "question": "What is the primary benefit of using the Page Object Model (POM) in test automation?",
    "options": [
      "To make test execution significantly faster",
      "To separate test case logic from UI interaction logic, making tests more maintainable and less brittle to UI changes",
      "To automatically generate test data for the application",
      "To replace the need for a testing framework like JUnit or TestNG"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "POM separates test logic from UI structure, making maintenance easier when the UI changes."
  },
  {
    "question": "In the context of testing frameworks like pytest, what is the primary role of a fixture?",
    "options": [
      "To store and parameterize test data, allowing a single test to run with multiple inputs",
      "To perform the assertions or checks that determine if a test passes or fails",
      "To provide a fixed baseline for tests, managing setup and teardown logic",
      "To generate detailed reports and logs of test execution"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Fixtures in pytest handle setup and teardown logic, providing a consistent baseline for tests."
  },
  {
    "question": "In Selenium, which locator strategy is best suited to handle elements with dynamic IDs?",
    "options": [
      "By.ID",
      "By.CLASS_NAME",
      "XPath or CSS Selector",
      "By.NAME"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The By class provides mechanisms to locate web elements, like ID, name, or XPath."
  },
  {
    "question": "What's the best approach for managing test configuration?",
    "options": [
      "Hardcoding values directly in test scripts",
      "Storing configuration in a dedicated test database",
      "Using environment variables",
      "Using external configuration files that can be overridden by environment variables"
    ],
    "correct_answer_index": 3,
    "category": "Automation",
    "explanation": "Using external configuration files (JSON, YAML, INI) provides flexibility and maintainability, while environment variables allow overriding settings for different environments (dev, test, prod) without changing code."
  },
  {
    "question": "What's the best way to handle dynamic table content?",
    "options": [
      "Using absolute XPath to navigate the table structure",
      "Relying on fixed row and column indexes",
      "Locating table rows based on unique text in a specific column",
      "Getting all rows and iterating with a loop"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Using unique text content in a column provides a stable locator even when table structure changes. Absolute XPath and fixed indexes are brittle and break when content changes. Iterating all rows is inefficient and requires more complex logic."
  },
  {
    "question": "What's the output of `print(1 + \"2\" - 1)` in Python?",
    "options": [
      "2",
      "\"12-1\"",
      "0",
      "A TypeError will be raised"
    ],
    "correct_answer_index": 3,
    "category": "Python",
    "explanation": "Mixing integers and strings in arithmetic operations raises a TypeError in Python."
  },
  {
    "question": "Which of the following completes the code `current_url = driver.______` to get the current URL of the page in Selenium?",
    "options": [
      "get_current_url()",
      "current_url",
      "url",
      "page_source"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.current_url retrieves the current page’s URL as a string."
  },
  {
    "question": "In Python's unittest framework, what method is used to assert that two values are equal?",
    "options": [
      "assert_equals(a, b)",
      "assertTrue(a == b)",
      "assertEqual(a, b)",
      "assert(a == b)"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "assertEqual(a, b) is the standard unittest method to compare expected and actual values."
  },
  {
    "question": "What's the output of `print(5 == \"5\")` in Python?",
    "options": [
      "True",
      "False",
      "A TypeError will be raised",
      "A SyntaxError will be raised"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Python does not perform type coercion with the == operator. The integer 5 and string \"5\" are different types and values, so the comparison returns False."
  },
  {
    "question": "What is the correct method to launch a browser in Selenium using Python?",
    "options": [
      "start_browser()",
      "get()",
      "launch()",
      "open()"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.get('url') is the standard Selenium WebDriver method used to navigate to a specified URL. It loads the page and waits for it to complete loading before continuing script execution."
  },
  {
    "question": "What is the best and most idiomatic way of handling exceptions in Python?",
    "options": [
      "Using if-else conditional blocks",
      "try-catch blocks",
      "Using specific try-except blocks",
      "Ignoring exceptions to prevent crashes"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Using specific try-except blocks (e.g., except ValueError, except FileNotFoundError) allows precise error handling, better debugging, and prevents accidentally catching unexpected exceptions that should propagate."
  },
  {
    "question": "In general, what is the best practice for handling unexpected errors (e.g., an element not found) during the execution of an automated functional test?",
    "options": [
      "The error should be logged, and the test should continue to execute subsequent steps.",
      "The script should use a try-except block to catch and ignore the error, allowing the test to pass.",
      "The test should fail immediately at the point of the error, clearly reporting the cause.",
      "The test should pause and wait for manual intervention to fix the issue before continuing."
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "Tests should fail fast to provide immediate, actionable feedback. Continuing after errors can cascade into false positives/negatives and obscure the root cause. Clear failure reports enable quick debugging."
  },
  {
    "question": "What is the most reliable method to specifically wait for an element to become visible on a web page before interacting with it?",
    "options": [
      "Using driver.implicitly_wait(10) at the start of the test.",
      "Using WebDriverWait with ExpectedConditions.presence_of_element_located()",
      "Using WebDriverWait with ExpectedConditions.visibility_of_element_located()",
      "Using a static time.sleep(5) before the element interaction."
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "visibility_of_element_located() waits for the element to be both present in the DOM and visible (not hidden). presence_of_element_located() only checks DOM presence, not visibility. Static sleeps waste time and are unreliable."
  },
  {
    "question": "Given the following Python code, what will be printed to the console?",
    "code_snippet": "my_set = {1, 2, 3}\nmy_set.add(3)\nmy_set.add(4)\nprint(len(my_set))",
    "options": [
      "3",
      "4",
      "5",
      "The code will raise an exception"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Sets automatically ignore duplicate values. Adding 3 again has no effect since it's already in the set. After adding 4, the set contains {1, 2, 3, 4}, so len() returns 4."
  },
  {
    "question": "In Selenium, how can you execute a piece of JavaScript code within the context of the current page?",
    "options": [
      "driver.run_javascript('alert(\"hello\")')",
      "driver.execute_script('alert(\"hello\")')",
      "driver.javascript('alert(\"hello\")')",
      "driver.inject_script('alert(\"hello\")')"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.execute_script() is the Selenium method for running JavaScript in the browser context. This is useful for interacting with elements not directly accessible via Selenium's API or for custom actions."
  },
  {
    "question": "In the context of test automation, what is the main purpose of a 'smoke test' suite?",
    "options": [
      "To perform in-depth testing of a specific feature.",
      "To verify that the most critical functionalities of the application are working after a new build, before more extensive testing is done.",
      "To test the application under heavy load to identify performance bottlenecks.",
      "To run all regression tests to ensure new changes haven't broken existing functionality."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Smoke tests are quick, high-level checks that verify the application is stable enough for further testing. They catch major breaks early, saving time by preventing full test suite runs on broken builds."
  },
  {
    "question": "What is the correct way to switch to an iframe with the name 'my_frame' in Selenium?",
    "code_snippet": "from selenium.webdriver.remote.webdriver import WebDriver\n\ndriver: WebDriver\n# Assume driver is initialized\n# How to switch to the iframe?",
    "options": [
      "driver.switch_to(frame='my_frame')",
      "driver.switch_to_iframe('my_frame')",
      "driver.switch_to.frame('my_frame')",
      "driver.select_frame('my_frame')"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "Use driver.switch_to.frame('my_frame') to target a specific frame by name or ID."
  },
  {
    "question": "Which of the following correctly uses an f-string in Python for string formatting?",
    "options": [
      "name = 'World'\nprint('Hello, {name}')",
      "name = 'World'\nprint(f'Hello, {name}')",
      "name = 'World'\nprint('Hello, %s' % name)",
      "name = 'World'\nprint('Hello, {}'.format(name))"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "F-strings (formatted string literals) use the 'f' prefix before the string and evaluate expressions inside curly braces {}. They are the modern, most readable way to format strings in Python 3.6+."
  },
  {
    "question": "In test automation, what is a 'flaky' test?",
    "options": [
      "A test that is designed to always fail to check the reporting system.",
      "A test that passes and fails intermittently without any changes to the code or the test environment.",
      "A test that takes a very long time to execute.",
      "A test that covers a non-critical feature of the application."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "A flaky test passes or fails inconsistently without code changes, often due to timing or environment."
  },
  {
    "question": "How do you perform a right-click action on an element using Selenium's ActionChains?",
    "code_snippet": "from selenium.webdriver.common.action_chains import ActionChains\n\n# Assume 'driver' and 'element' are defined\n\n# How to perform a right-click?",
    "options": [
      "ActionChains(driver).right_click(element).perform()",
      "ActionChains(driver).context_click(element).perform()",
      "ActionChains(driver).click(element, 'right').perform()",
      "element.right_click()"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "ActionChains(driver).context_click(element).perform() performs a right-click on the element."
  },
  {
    "question": "What is the primary difference between a Python list and a tuple?",
    "options": [
      "Lists can store items of different data types, while tuples can only store items of the same type.",
      "Lists are mutable (changeable), while tuples are immutable (unchangeable).",
      "Lists use square brackets `[]`, while tuples use curly braces `{}`.",
      "Lists are ordered and indexed, while tuples are unordered."
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Lists can be modified after creation (add, remove, change items), while tuples cannot be changed once created. Use tuples for data that shouldn't change, and lists for dynamic collections."
  },
  {
    "question": "What is the purpose of the `finally` block in a Python `try...except` statement?",
    "options": [
      "It contains the code that will be executed only if an exception occurs.",
      "It is where you define the custom exception to be raised.",
      "It contains the code that will be executed only if no exception occurs.",
      "It contains the code that will be executed regardless of whether an exception occurred or not."
    ],
    "correct_answer_index": 3,
    "category": "Python",
    "explanation": "The finally block always executes, making it ideal for cleanup operations like closing files, releasing resources, or logging. It runs whether an exception occurs or not, and even if there's a return statement."
  },
  {
    "question": "Which of the following is NOT a valid Selenium locator strategy in the `By` class?",
    "options": [
      "By.XPATH",
      "By.CSS_SELECTOR",
      "By.TAG_NAME",
      "By.JQUERY_SELECTOR"
    ],
    "correct_answer_index": 3,
    "category": "Selenium",
    "explanation": "The By class provides mechanisms to locate web elements, like ID, name, or XPath."
  },
  {
    "question": "In a Behavior-Driven Development (BDD) framework using Gherkin, what is the purpose of the 'Given', 'When', 'Then' keywords?",
    "options": [
      "To define Python functions for the test.",
      "To structure the test in a human-readable format describing a feature's behavior from a user's perspective.",
      "To import necessary libraries and modules for the test.",
      "To set the priority and order of test execution."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Gherkin's Given-When-Then syntax creates human-readable test scenarios: Given sets preconditions, When describes actions, Then verifies outcomes. This bridges communication between technical and non-technical stakeholders."
  },
  {
    "question": "What will be the output of the following Python list comprehension?",
    "code_snippet": "squares = [x * x for x in range(5)]\nprint(squares)",
    "options": [
      "[1, 4, 9, 16, 25]",
      "[0, 1, 4, 9, 16]",
      "[0, 1, 2, 3, 4]",
      "The code will raise a syntax error."
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "List comprehensions provide a compact way to generate lists; range(5) gives 0–4, so squares are [0, 1, 4, 9, 16]."
  },
  {
    "question": "What is the key difference between `driver.find_element()` and `driver.find_elements()` in Selenium?",
    "options": [
      "`find_element()` returns the first matching element or raises an exception if not found, while `find_elements()` returns a list of all matching elements or an empty list if none are found.",
      "`find_element()` is used for single elements and `find_elements()` is for multiple, but both raise an exception if no elements are found.",
      "`find_element()` returns a single WebElement, while `find_elements()` returns a generator object.",
      "There is no functional difference; `find_elements()` is just an alias for `find_element()`."
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "find_element() expects exactly one match and raises NoSuchElementException if not found. find_elements() returns a list (empty if no matches), which is safer when you're unsure if elements exist or need to check multiple matches."
  },
  {
    "question": "In Python, what is the primary difference between accessing a dictionary value with `my_dict['key']` versus `my_dict.get('key')`?",
    "options": [
      "They are identical; `.get()` is just a more verbose way of doing the same thing.",
      "`my_dict['key']` is faster, but `my_dict.get('key')` can provide a default value if the key is not found.",
      "`my_dict['key']` will raise a `KeyError` if the key does not exist, whereas `my_dict.get('key')` will return `None` by default.",
      "`my_dict['key']` can only be used for string keys, while `.get()` works with any hashable type."
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Bracket notation my_dict['key'] raises KeyError for missing keys, requiring exception handling. The .get() method returns None (or a specified default) for missing keys, making code more defensive and readable."
  },
  {
    "question": "What is the purpose of a Python virtual environment?",
    "options": [
      "To run Python scripts with elevated administrator privileges securely.",
      "To create a simulated operating system for testing cross-platform compatibility.",
      "To create an isolated environment with its own set of packages and dependencies, separate from the system-wide Python installation.",
      "To improve the performance of Python scripts by pre-compiling them to machine code."
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Virtual environments isolate Python dependencies from the system installation for cleaner management."
  },
  {
    "question": "What is the most common cause of a `StaleElementReferenceException` in Selenium?",
    "options": [
      "The browser window has been resized, invalidating element coordinates.",
      "The element was located, but the DOM was updated (e.g., via AJAX or page navigation) before the script could interact with it.",
      "The wrong locator strategy was used, so the element was never correctly identified.",
      "The browser's cache was cleared during the test run."
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "A StaleElementReferenceException occurs when the DOM updates after locating the element."
  },
  {
    "question": "What is regression testing in the context of software quality assurance?",
    "options": [
      "Testing a new feature to ensure it meets all specified requirements.",
      "The process of re-running existing tests to ensure that recent code changes have not introduced new bugs or broken existing functionality.",
      "A type of performance testing to see how the application degrades under heavy load.",
      "Manual testing performed by end-users to find usability issues."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Regression testing re-runs existing tests to confirm that new changes didn’t break old functionality."
  },
  {
    "question": "In pytest, what is the primary purpose of the `@pytest.mark.parametrize` decorator?",
    "options": [
      "To mark a test as belonging to a specific group or category.",
      "To run the same test function multiple times with different sets of arguments.",
      "To skip a test if a certain condition is not met.",
      "To specify a dependency, ensuring one test runs before another."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "@pytest.mark.parametrize allows data-driven testing by running the same test with different input values. Each parameter set creates a separate test case, improving coverage without code duplication."
  },
  {
    "question": "Given the following Python code, what is the output of `my_function(1, 2, c=3, d=4)`?",
    "code_snippet": "def my_function(a, b, *args, **kwargs):\n    print(f\"a={a}, b={b}, args={args}, kwargs={kwargs}\")",
    "options": [
      "a=1, b=2, args=(), kwargs={'c': 3, 'd': 4}",
      "a=1, b=2, args=(3, 4), kwargs={}",
      "The code will raise a TypeError because of unexpected keyword arguments.",
      "a=1, b=2, c=3, d=4, args=(), kwargs={}"
    ],
    "correct_answer_index": 0,
    "category": "Python",
    "explanation": "Positional arguments 1 and 2 are assigned to a and b. Since no extra positional args are provided, args is an empty tuple. Named arguments c=3 and d=4 are captured in the kwargs dictionary."
  },
  {
    "question": "Which Selenium method is generally preferred for clearing text from an input field before typing new text?",
    "options": [
      "Sending the backspace key repeatedly with `send_keys()`.",
      "Executing a JavaScript command to set the element's value to an empty string.",
      "Using the `.clear()` method on the web element.",
      "Using `send_keys(\"\")` to send an empty string."
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The clear() method empties an input field before sending new text, ensuring clean entry."
  },
  {
    "question": "What is a Python lambda function?",
    "options": [
      "A standard function defined with the `def` keyword that is stored in a special, faster memory location.",
      "A small, anonymous, single-expression function defined with the `lambda` keyword.",
      "A function that can only be used within a class definition.",
      "A built-in function for running code in parallel."
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "A lambda defines an anonymous single-expression function; here, it filters even numbers."
  },
  {
    "question": "How can you take a screenshot of the current browser window in Selenium?",
    "options": [
      "driver.get_screenshot()",
      "driver.save_screenshot('my_screenshot.png')",
      "driver.take_screenshot(file='my_screenshot.png')",
      "driver.capture_screen('my_screenshot.png')"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.save_screenshot('filename.png') captures the current browser viewport and saves it to the specified file path. This is invaluable for debugging test failures and documenting test execution."
  },
  {
    "question": "In test automation, what does the principle of 'Data-Driven Testing' refer to?",
    "options": [
      "Testing how the application handles large volumes of data.",
      "A method where test data is stored in a database and queried during test execution.",
      "An approach where test logic is separated from the test data, allowing the same test script to be executed with multiple data sets, often read from an external source (like a spreadsheet or CSV file).",
      "Automatically generating random data to use as input for tests."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Data-driven testing separates test logic from input data, running the same test with multiple datasets."
  },
  {
    "question": "What will be printed to the console by the following Python code?",
    "code_snippet": "data = [1, 2, 3, 4, 5]\nresult = list(filter(lambda x: x % 2 == 0, data))\nprint(result)",
    "options": [
      "[1, 3, 5]",
      "[2, 4]",
      "The code will raise a TypeError.",
      "[False, True, False, True, False]"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "The filter() function applies the lambda to each element, keeping only those where x % 2 == 0 (even numbers). This filters [1,2,3,4,5] to [2,4]."
  },
  {
    "question": "Which code snippet correctly performs a 'drag and drop' action in Selenium?",
    "options": [
      "ActionChains(driver).click(source).release(target).perform()",
      "ActionChains(driver).drag(source, target).perform()",
      "ActionChains(driver).drag_and_drop(source, target).perform()",
      "ActionChains(driver).move_to_element(source).click_and_hold().move_to_element(target).release().perform()"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "ActionChains(driver).drag_and_drop(source, target).perform() is the concise, idiomatic way to drag an element from source to target. It handles the click-hold-move-release sequence automatically."
  },
  {
    "question": "What is the output of the following Python code?",
    "code_snippet": "my_list = ['a', 'b', 'c', 'd', 'e']\nremoved_item = my_list.pop(2)\nprint(removed_item, my_list)",
    "options": [
      "b ['a', 'c', 'd', 'e']",
      "c ['a', 'b', 'd', 'e']",
      "d ['a', 'b', 'c', 'e']",
      "None ['a', 'b', 'd', 'e']"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "list.pop(2) removes and returns the element at index 2 (zero-based), which is 'c'. The list is modified in place, leaving ['a', 'b', 'd', 'e']."
  },
  {
    "question": "Complete the following Selenium code to wait until an element is clickable.",
    "code_snippet": "from selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\n\nwait = WebDriverWait(driver, 10)\nelement = wait.until(EC.______( (By.ID, 'submit-btn') ))",
    "options": [
      "visibility_of_element_located",
      "presence_of_element_located",
      "element_to_be_clickable",
      "element_to_be_selected"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "element_to_be_clickable waits until the element is both visible and enabled, ensuring it can actually be clicked. This prevents ElementNotInteractableException errors."
  },
  {
    "question": "Which line of code is required to make a hidden menu visible by hovering the mouse over its parent element?",
    "code_snippet": "from selenium.webdriver.common.action_chains import ActionChains\n\nmenu_trigger = driver.find_element(By.ID, 'menu-trigger')\n# Missing code here to make the menu appear\n",
    "options": [
      "ActionChains(driver).hover(menu_trigger).perform()",
      "ActionChains(driver).move_to_element(menu_trigger).perform()",
      "driver.execute_script('arguments[0].hover();', menu_trigger)",
      "menu_trigger.hover()"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "ActionChains(driver).move_to_element(menu_trigger).perform() simulates hovering the mouse over an element, which triggers CSS :hover effects and reveals hidden menus."
  },
  {
    "question": "What will be printed after running this Python code?",
    "code_snippet": "numbers = [1, 2, 3, 4, 5]\nnew_list = [n * 2 for n in numbers if n % 2 != 0]\nprint(new_list)",
    "options": [
      "[2, 4, 6, 8, 10]",
      "[1, 3, 5]",
      "[4, 10]",
      "[2, 6, 10]"
    ],
    "correct_answer_index": 3,
    "category": "Python",
    "explanation": "The comprehension filters for odd numbers (n % 2 != 0), giving [1, 3, 5], then multiplies each by 2, resulting in [2, 6, 10]."
  },
  {
    "question": "Fill in the blank to complete the code that checks if a checkbox is selected.",
    "code_snippet": "checkbox = driver.find_element(By.ID, 'terms-and-conditions')\nif checkbox.______:\n    print('Checkbox is already selected.')",
    "options": [
      "is_selected()",
      "is_checked()",
      "get_attribute('selected')",
      "is_enabled()"
    ],
    "correct_answer_index": 0,
    "category": "Automation",
    "explanation": "is_selected() is a method that returns True if a checkbox, radio button, or option is selected, and False otherwise. Note the parentheses—it's a method, not a property."
  },
  {
    "question": "How do you correctly use ActionChains to press the SHIFT key, type 'hello', and then release the SHIFT key?",
    "options": [
      "ActionChains(driver).press(Keys.SHIFT).send_keys('hello').release(Keys.SHIFT).perform()",
      "ActionChains(driver).key_down(Keys.SHIFT).send_keys('hello').key_up(Keys.SHIFT).perform()",
      "ActionChains(driver).send_keys(Keys.SHIFT, 'hello').perform()",
      "ActionChains(driver).send_keys_with_modifier(Keys.SHIFT, 'hello').perform()"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "key_down() presses and holds a modifier key, send_keys() types text while it's held, and key_up() releases it. This pattern simulates holding SHIFT while typing, resulting in 'HELLO'."
  },
  {
    "question": "What is the output of this Python code snippet that uses list slicing?",
    "code_snippet": "letters = ['a', 'b', 'c', 'd', 'e', 'f']\nprint(letters[1:4])",
    "options": [
      "['a', 'b', 'c', 'd']",
      "['b', 'c', 'd']",
      "['b', 'c', 'd', 'e']",
      "['a', 'b', 'c']"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "List slicing [start:end] extracts elements from index start up to (but not including) index end. letters[1:4] gets indices 1, 2, and 3, which are ['b', 'c', 'd']."
  },
  {
    "question": "Complete the Python code to get the text content of a web element.",
    "code_snippet": "page_heading = driver.find_element(By.TAG_NAME, 'h1')\nheading_text = page_heading.______",
    "options": [
      "get_text()",
      "text()",
      "text",
      "inner_html"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The .text property (not a method) retrieves the visible text content of a web element. It returns the innerText, excluding HTML tags but including visible child elements' text."
  },
  {
    "question": "Which action is NOT typically performed using the ActionChains class in Selenium?",
    "options": [
      "Double-clicking an element.",
      "Navigating to a new URL.",
      "Right-clicking an element.",
      "Dragging and dropping an element."
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "ActionChains is for complex mouse and keyboard interactions (clicks, drags, hovers). Navigation (driver.get()) is a basic WebDriver method that doesn't require ActionChains."
  },
  {
    "question": "What is the result of the following Python code?",
    "code_snippet": "list_a = [1, 2, 3]\nlist_b = list_a\nlist_b.append(4)\nprint(list_a)",
    "options": [
      "[1, 2, 3]",
      "[1, 2, 3, 4]",
      "The code will raise an error because you cannot assign a list to another.",
      "[4]"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "list_b = list_a creates a reference to the same list object, not a copy. Modifying list_b also modifies list_a since they point to the same memory. Use list_a.copy() or list(list_a) to create an independent copy."
  },
  {
    "question": "Fill in the blank to navigate the browser to a specific URL.",
    "code_snippet": "from selenium import webdriver\n\ndriver = webdriver.Chrome()\ndriver.______('https://www.google.com')",
    "options": [
      "open",
      "navigate",
      "get",
      "load_page"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "driver.get('url') is the standard Selenium WebDriver method to navigate the browser to a specified URL. It waits for the page to load before continuing execution."
  },
  {
    "question": "Which pytest hook is executed before each test function runs?",
    "options": [
      "pytest_sessionstart",
      "pytest_runtest_setup",
      "pytest_runtest_teardown",
      "pytest_fixture_setup"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "pytest_runtest_setup is called before each test function executes, allowing setup actions to be performed.",
    "new": true
  },
  {
    "question": "In automation testing, when should you prefer logging over assertions?",
    "options": [
      "When verifying critical functionality that must pass.",
      "When you need to record runtime information without stopping the test.",
      "When you want the test to fail immediately on unexpected behavior.",
      "When you are testing exception handling code."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Logging provides runtime information and context for debugging, while assertions validate conditions and fail tests if unmet.",
    "new": true
  },
  {
    "question": "How can you run a Chrome browser in headless mode using Selenium 4?",
    "code_snippet": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\n# Missing line here\n",
    "options": [
      "options.headless = True",
      "options.set_headless(True)",
      "options.add_argument('--headless')",
      "options.run_in_background(True)"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "options.add_argument('--headless') enables Chrome to run without a GUI, ideal for CI/CD environments.",
    "new": true
  },
  {
    "question": "What is the key difference between explicit and fluent waits in Selenium?",
    "options": [
      "Fluent waits can ignore specific exceptions and poll at intervals, while explicit waits wait for a condition up to a maximum time.",
      "Explicit waits are faster but less flexible than fluent waits.",
      "Fluent waits are deprecated in Selenium 4.",
      "There is no difference; both behave identically."
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "FluentWait allows custom polling frequency and ignored exceptions, providing more control than standard explicit waits.",
    "new": true
  },
  {
    "question": "Which Python library is commonly used for simple REST API test automation?",
    "options": [
      "http.client",
      "urllib",
      "requests",
      "json"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "The requests library simplifies sending HTTP requests and validating API responses in test automation.",
    "new": true
  },
  {
    "question": "What will be the output of the following Python code?",
    "code_snippet": "def multiply(a, b=2, c=3):\n    return a * b * c\n\nresult = multiply(5, c=4)\nprint(result)",
    "options": [
      "30",
      "40",
      "60",
      "The code will raise a TypeError"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "The function is called with a=5 (positional), b=2 (default), and c=4 (keyword). The result is 5 * 2 * 4 = 40."
  },
  {
    "question": "How can you handle alert pop-ups in Selenium?",
    "code_snippet": "# Assume an alert has appeared on the page\n# How to accept the alert?",
    "options": [
      "driver.accept_alert()",
      "driver.switch_to.alert.accept()",
      "driver.alert().accept()",
      "driver.handle_alert(accept=True)"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.switch_to.alert switches context to the alert, and .accept() clicks the OK button. You can also use .dismiss() to cancel or .text to read the alert message."
  },
  {
    "question": "What is the purpose of a test harness in automation testing?",
    "options": [
      "A tool that generates random test data for testing purposes.",
      "A collection of software and test data configured to test a program by running it under varying conditions and monitoring its behavior.",
      "A specialized IDE for writing automated tests.",
      "A database that stores all test execution results."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "A test harness is an environment that provides the infrastructure to execute tests, including drivers, stubs, mock objects, and utilities needed to run tests systematically."
  },
  {
    "question": "What is the output of the following Python code?",
    "code_snippet": "x = [1, 2, 3]\ny = x[:]\ny.append(4)\nprint(len(x), len(y))",
    "options": [
      "3 3",
      "4 4",
      "3 4",
      "4 3"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "x[:] creates a shallow copy of the list, so y is independent of x. Appending 4 to y doesn't affect x. Therefore, x has length 3 and y has length 4."
  },
  {
    "question": "Which Selenium method allows you to get the value of an element's attribute?",
    "code_snippet": "input_field = driver.find_element(By.ID, 'username')\n# How to get the 'placeholder' attribute value?",
    "options": [
      "input_field.attribute('placeholder')",
      "input_field.get_attribute('placeholder')",
      "input_field.attr('placeholder')",
      "input_field.value_of('placeholder')"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "element.get_attribute('attribute_name') retrieves the value of any HTML attribute, such as id, class, href, value, or custom data attributes."
  },
  {
    "question": "In test-driven development (TDD), when should you write the test code?",
    "options": [
      "After implementing the feature completely.",
      "Before writing the implementation code.",
      "Only for complex features that are difficult to test manually.",
      "After the application is deployed to production."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "TDD follows the Red-Green-Refactor cycle: write a failing test first, then write code to make it pass, then refactor. This ensures code meets requirements and is testable."
  },
  {
    "question": "What will be printed by the following Python code?",
    "code_snippet": "def outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x = 20\n    inner()\n    print(x)\n\nouter()",
    "options": [
      "10",
      "20",
      "The code will raise a NameError",
      "The code will raise a SyntaxError"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "The 'nonlocal' keyword allows the inner function to modify the variable x from the enclosing outer function's scope. After inner() executes, x is changed to 20."
  },
  {
    "question": "How can you select an option from a dropdown menu in Selenium?",
    "code_snippet": "from selenium.webdriver.support.ui import Select\n\ndropdown = driver.find_element(By.ID, 'country')\n# How to select the option with visible text 'Canada'?",
    "options": [
      "dropdown.select('Canada')",
      "Select(dropdown).select_by_visible_text('Canada')",
      "dropdown.click('Canada')",
      "Select(dropdown).choose('Canada')"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "The Select class provides methods to interact with <select> elements: select_by_visible_text(), select_by_value(), and select_by_index()."
  },
  {
    "question": "What is the primary benefit of parallel test execution in automation?",
    "options": [
      "It makes tests easier to write and maintain.",
      "It reduces the overall test execution time by running multiple tests simultaneously.",
      "It automatically fixes flaky tests.",
      "It eliminates the need for test data management."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Parallel execution runs tests concurrently across multiple threads or machines, significantly reducing total execution time, especially for large test suites."
  },
  {
    "question": "What is the result of this Python code?",
    "code_snippet": "my_dict = {'a': 1, 'b': 2, 'c': 3}\nresult = {v: k for k, v in my_dict.items()}\nprint(result)",
    "options": [
      "{'a': 1, 'b': 2, 'c': 3}",
      "{1: 'a', 2: 'b', 3: 'c'}",
      "{'1': 'a', '2': 'b', '3': 'c'}",
      "The code will raise a TypeError"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Dictionary comprehension {v: k for k, v in my_dict.items()} swaps keys and values, creating a new dictionary where original values become keys."
  },
  {
    "question": "What happens if you call driver.find_element() with an invalid locator strategy in Selenium?",
    "options": [
      "It returns None",
      "It returns an empty list",
      "It raises a NoSuchElementException",
      "It raises an InvalidSelectorException"
    ],
    "correct_answer_index": 3,
    "category": "Selenium",
    "explanation": "An invalid locator (e.g., malformed XPath or CSS selector) raises InvalidSelectorException. NoSuchElementException is raised when the locator is valid but no element matches."
  },
  {
    "question": "What is continuous integration (CI) in the context of test automation?",
    "options": [
      "A practice where developers merge code changes frequently, with each merge triggering automated builds and tests.",
      "A type of integration testing performed manually by QA engineers.",
      "A deployment strategy where new features are released continuously to production.",
      "A method of integrating third-party APIs into an application."
    ],
    "correct_answer_index": 0,
    "category": "Automation",
    "explanation": "CI automates building and testing code changes frequently (often multiple times per day), catching integration issues early and providing fast feedback to developers."
  },
  {
    "question": "What will the following Python code print?",
    "code_snippet": "numbers = [1, 2, 3, 4, 5]\ntry:\n    print(numbers[10])\nexcept IndexError:\n    print('Index out of range')\nexcept Exception as e:\n    print(f'Other error: {e}')",
    "options": [
      "5",
      "None",
      "Index out of range",
      "Other error: list index out of range"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Accessing index 10 in a 5-element list raises IndexError. The first matching except block catches it and prints 'Index out of range'. More specific exceptions are caught before general ones."
  },
  {
    "question": "How do you switch back to the main page content after switching to an iframe in Selenium?",
    "options": [
      "driver.switch_to.main_content()",
      "driver.switch_to.parent_frame()",
      "driver.switch_to.default_content()",
      "driver.exit_frame()"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "driver.switch_to.default_content() switches context back to the main page. Use parent_frame() to go up one level in nested iframes, or default_content() to return to the top level."
  },
  {
    "question": "What is a test oracle in software testing?",
    "options": [
      "A database that stores expected test results.",
      "An automated tool that generates test cases.",
      "A mechanism to determine whether a test has passed or failed by comparing actual results with expected outcomes.",
      "A senior tester who reviews all test cases before execution."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "A test oracle is a source of expected results used to verify test outcomes. It can be specifications, existing systems, or domain knowledge that defines correct behavior."
  },
  {
    "question": "What is the output of this Python code?",
    "code_snippet": "class Counter:\n    count = 0\n    \n    def __init__(self):\n        Counter.count += 1\n\nc1 = Counter()\nc2 = Counter()\nc3 = Counter()\nprint(Counter.count)",
    "options": [
      "0",
      "1",
      "3",
      "The code will raise an AttributeError"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Counter.count is a class variable shared across all instances. Each time __init__ runs, it increments the shared counter. Three instances mean count becomes 3."
  },
  {
    "question": "Which method is used to maximize the browser window in Selenium?",
    "options": [
      "driver.maximize()",
      "driver.window.maximize()",
      "driver.maximize_window()",
      "driver.set_window_size('max')"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "driver.maximize_window() maximizes the browser window to fill the screen. This ensures consistent viewport size and can prevent element visibility issues in tests."
  },
  {
    "question": "What is the purpose of a mock object in unit testing?",
    "options": [
      "To test the application's performance under load.",
      "To simulate the behavior of real objects in a controlled way, allowing isolated testing of specific components.",
      "To automatically generate test data for test cases.",
      "To record all function calls made during test execution."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Mock objects simulate dependencies (databases, APIs, external services) with controlled behavior, enabling isolated unit tests without requiring actual external resources."
  },
  {
    "question": "What will this Python code output?",
    "code_snippet": "text = 'hello world'\nresult = text.split()[1].upper()\nprint(result)",
    "options": [
      "'HELLO'",
      "'WORLD'",
      "'hello world'",
      "'World'"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "text.split() splits the string into ['hello', 'world']. Index [1] gets 'world', and .upper() converts it to 'WORLD'."
  },
  {
    "question": "How can you scroll to a specific element in Selenium using JavaScript?",
    "code_snippet": "element = driver.find_element(By.ID, 'footer')\n# How to scroll to this element?",
    "options": [
      "driver.scroll_to(element)",
      "element.scroll_into_view()",
      "driver.execute_script('arguments[0].scrollIntoView();', element)",
      "ActionChains(driver).scroll_to_element(element).perform()"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "driver.execute_script('arguments[0].scrollIntoView();', element) uses JavaScript to scroll the element into the visible area of the browser window."
  },
  {
    "question": "What is the main advantage of using a keyword-driven testing framework?",
    "options": [
      "It automatically generates test data for all test cases.",
      "It allows non-technical users to create tests using predefined keywords without writing code.",
      "It makes tests run faster than other frameworks.",
      "It eliminates the need for assertions in test cases."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Keyword-driven frameworks abstract test logic into reusable keywords (actions like 'login', 'click_button'), enabling non-programmers to create tests using simple, readable syntax."
  },
  {
    "question": "What is the result of the following Python code?",
    "code_snippet": "a = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b, a is b)",
    "options": [
      "True True",
      "False False",
      "True False",
      "False True"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "== checks value equality (True, both lists contain [1, 2, 3]), while 'is' checks identity (False, they're different objects in memory)."
  },
  {
    "question": "What is the correct way to close a specific browser window in Selenium when multiple windows are open?",
    "options": [
      "driver.close()",
      "driver.quit()",
      "driver.close_window()",
      "driver.switch_to.window().close()"
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "driver.close() closes the current window/tab. driver.quit() closes all windows and ends the WebDriver session. Use window_handles to switch between windows before closing."
  },
  {
    "question": "In automation testing, what is test coverage?",
    "options": [
      "The percentage of tests that pass successfully.",
      "The number of test cases executed per hour.",
      "A measure of how much of the application code or requirements are tested by the test suite.",
      "The total time taken to execute all automated tests."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Test coverage measures the extent to which testing exercises the code (code coverage) or requirements (requirement coverage), helping identify untested areas."
  },
  {
    "question": "What will be printed by this Python code?",
    "code_snippet": "def modify_list(lst):\n    lst = lst + [4, 5]\n    return lst\n\noriginal = [1, 2, 3]\nmodified = modify_list(original)\nprint(original, modified)",
    "options": [
      "[1, 2, 3] [1, 2, 3, 4, 5]",
      "[1, 2, 3, 4, 5] [1, 2, 3, 4, 5]",
      "[1, 2, 3, 4, 5] [1, 2, 3]",
      "The code will raise a TypeError"
    ],
    "correct_answer_index": 0,
    "category": "Python",
    "explanation": "The + operator creates a new list object rather than modifying the original. The reassignment lst = lst + [4, 5] creates a new local reference, leaving 'original' unchanged."
  },
  {
    "question": "How can you get all currently open window handles in Selenium?",
    "options": [
      "driver.window_handles",
      "driver.get_windows()",
      "driver.all_windows()",
      "driver.list_handles()"
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "driver.window_handles returns a list of all window handle strings. You can iterate through these and use driver.switch_to.window(handle) to switch between windows."
  },
  {
    "question": "What is boundary value analysis in testing?",
    "options": [
      "Testing only the maximum values that an input can accept.",
      "A testing technique that focuses on values at the boundaries of input ranges, where errors are most likely to occur.",
      "Testing the physical boundaries of the application's user interface.",
      "A performance testing method that measures response times at the limits of system capacity."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Boundary value analysis tests values at the edges of valid ranges (min, max, just below min, just above max) where defects commonly occur due to off-by-one errors."
  },
  {
    "question": "What is the output of this Python code?",
    "code_snippet": "import copy\n\noriginal = [[1, 2], [3, 4]]\nshallow = copy.copy(original)\ndeep = copy.deepcopy(original)\n\noriginal[0][0] = 99\nprint(shallow[0][0], deep[0][0])",
    "options": [
      "1 1",
      "99 99",
      "99 1",
      "1 99"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "copy.copy() creates a shallow copy that shares nested objects. copy.deepcopy() creates independent copies of all levels. Modifying original affects shallow but not deep."
    },
    {
      "question": "In Python, what is the primary purpose of a context manager used with the 'with' statement?",
      "options": [
        "To guarantee that setup and cleanup of a resource happen reliably, even if an exception is raised",
        "To improve performance of loop execution",
        "To automatically cache function return values",
        "To force garbage collection of unused objects"
      ],
      "correct_answer_index": 0,
      "category": "Python",
      "explanation": "Context managers implement __enter__ and __exit__ to ensure deterministic acquisition and release of resources (files, locks, network connections) regardless of success or failure inside the block.",
      "new": true
    },
    {
      "question": "Which statement best describes the difference between an iterable and an iterator in Python?",
      "options": [
        "An iterable implements __next__ only; an iterator implements __iter__ only",
        "An iterable can be looped over and provides an iterator via __iter__; an iterator produces values with __next__ until exhaustion",
        "They are identical; the terms are interchangeable",
        "Iterators must be lists; iterables must be generators"
      ],
      "correct_answer_index": 1,
      "category": "Python",
      "explanation": "Iterables define __iter__ returning an iterator. Iterators implement __next__ (and usually __iter__ returning self) to yield one item at a time until StopIteration.",
      "new": true
    },
    {
      "question": "What is a key advantage of using a generator function (yield) over building a list and returning it?",
      "options": [
        "Generators automatically parallelize execution",
        "Generators allow lazy production of values, reducing memory consumption for large or infinite sequences",
        "Generators always run faster than list comprehensions",
        "Generators prevent exceptions from propagating"
      ],
      "correct_answer_index": 1,
      "category": "Python",
      "explanation": "Generators yield items one at a time, avoiding storing all results in memory. This is ideal for streaming, large datasets, or potentially unbounded sequences.",
      "new": true
    },
    {
      "question": "Why is using a mutable object (e.g., []) as a default parameter generally discouraged in Python?",
      "options": [
        "It causes a syntax error",
        "The function becomes significantly slower",
        "The same object is reused across calls, leading to unintended state sharing",
        "It prevents the function from accepting keyword arguments"
      ],
      "correct_answer_index": 2,
      "category": "Python",
      "explanation": "Default parameter values are evaluated once at function definition time. Mutable defaults (like lists or dicts) persist changes between calls, often causing subtle bugs.",
      "new": true
    },
    {
      "question": "What is the primary benefit of using @dataclass for simple Python classes?",
      "options": [
        "It automatically parallelizes attribute access",
        "It generates common boilerplate methods (e.g., __init__, __repr__, __eq__) based on declared fields",
        "It encrypts attribute values at runtime",
        "It forces strict static typing enforcement"
      ],
      "correct_answer_index": 1,
      "category": "Python",
      "explanation": "@dataclass reduces boilerplate by auto-implementing __init__, __repr__, __eq__, and others from field definitions, improving readability and maintainability.",
      "new": true
    },
    {
      "question": "Which built-in data structure offers O(1) average-time membership tests for unordered unique elements?",
      "options": [
        "List",
        "Tuple",
        "Set",
        "Deque"
      ],
      "correct_answer_index": 2,
      "category": "Python",
      "explanation": "Sets use hash-based lookup providing average O(1) membership checks, making them ideal for uniqueness and fast containment tests.",
      "new": true
    },
    {
      "question": "What is the purpose of an __init__.py file in a Python package directory?",
      "options": [
        "To declare mandatory type hints for the package",
        "To mark the directory as a package and optionally define initialization logic or exports",
        "To improve interpreter performance when importing",
        "To disable relative imports inside the package"
      ],
      "correct_answer_index": 1,
      "category": "Python",
      "explanation": "__init__.py indicates a directory is a package and can expose a public API by defining __all__ or running setup code.",
      "new": true
    },
    {
      "question": "When iterating with index and value over a list, what is the most Pythonic approach?",
      "options": [
        "Use for i in range(0, len(items)): value = items[i]",
        "Use a while loop with manual index increment",
        "Use enumerate(items) to get (index, value) pairs directly",
        "Convert the list to a dict first"
      ],
      "correct_answer_index": 2,
      "category": "Python",
      "explanation": "enumerate() yields (index, item) pairs cleanly and readably without manual index management, reducing off-by-one errors.",
      "new": true
    },
    {
      "question": "In Selenium, what is the main difference between implicit and explicit waits?",
      "options": [
        "Implicit waits retry only click actions; explicit waits apply to navigation",
        "Implicit waits poll for all element finds up to a timeout; explicit waits target a specific condition for a specific element",
        "Explicit waits are deprecated; implicit waits are preferred",
        "There is no difference—both behave exactly the same"
      ],
      "correct_answer_index": 1,
      "category": "Selenium",
      "explanation": "Implicit waits set a global maximum time for locating elements. Explicit waits use WebDriverWait + ExpectedConditions for fine-grained readiness checks like visibility or clickability.",
      "new": true
    },
    {
      "question": "What is a reliable strategy for waiting on dynamic AJAX-loaded content?",
      "options": [
        "Always add a fixed time.sleep(10) before interactions",
        "Check document.readyState repeatedly with JavaScript",
        "Use an explicit wait for a stable, post-load element/state that appears only after the AJAX completes",
        "Reload the page until the element appears"
      ],
      "correct_answer_index": 2,
      "category": "Selenium",
      "explanation": "Waiting for a deterministic element or condition (e.g., visibility of a result container) is more stable than static sleeps and avoids brittle polling hacks.",
      "new": true
    },
    {
      "question": "What is the recommended way to upload a file using Selenium when an <input type='file'> is present?",
      "options": [
        "Drag the file onto the browser window",
        "Use ActionChains to simulate OS-level file dialogs",
        "Send the absolute file path string with send_keys() to the file input",
        "Execute JavaScript to bypass the control"
      ],
      "correct_answer_index": 2,
      "category": "Selenium",
      "explanation": "Providing the file path via element.send_keys(path) leverages native browser handling of file inputs without interacting with OS dialogs.",
      "new": true
    },
    {
      "question": "How can Shadow DOM elements typically be accessed in Selenium when standard locators fail?",
      "options": [
        "By using By.SHADOW directly",
        "By executing JavaScript to traverse shadowRoot and query selectors inside it",
        "By switching frames with switch_to.shadow()",
        "By enabling implicit shadow mode in capabilities"
      ],
      "correct_answer_index": 1,
      "category": "Selenium",
      "explanation": "Selenium does not natively pierce shadow boundaries; execute_script retrieving element.shadowRoot then querySelector within is the common approach.",
      "new": true
    },
    {
      "question": "Why is heavy reliance on brittle XPath like //div[3]/span[2] discouraged?",
      "options": [
        "It is slower than CSS by a factor of 100 always",
        "Such absolute positional XPaths often break with minor DOM changes; semantic attributes or stable IDs improve maintainability",
        "Browsers block positional XPath selectors",
        "It cannot be used in headless mode"
      ],
      "correct_answer_index": 1,
      "category": "Selenium",
      "explanation": "Absolute or index-heavy XPaths are fragile. Prefer descriptive locators: IDs, data-* attributes, accessible labels, or relative XPath tied to stable anchors.",
      "new": true
    },
    {
      "question": "What does the 'test pyramid' concept emphasize in automation strategy?",
      "options": [
        "Invest mostly in end-to-end UI tests and very few unit tests",
        "A broad base of fast unit tests, a middle layer of service/API tests, and a thin layer of slower UI tests",
        "Eliminate manual exploratory testing entirely",
        "Write only integration tests to reduce duplication"
      ],
      "correct_answer_index": 1,
      "category": "Automation",
      "explanation": "The pyramid favors many fast, reliable unit tests, fewer service-level tests, and minimal high-cost UI tests for efficiency and fast feedback.",
      "new": true
    },
    {
      "question": "What is a primary benefit of tagging tests (e.g., @pytest.mark.slow)?",
      "options": [
        "Tags make tests run faster automatically",
        "Tags allow selective execution (e.g., skipping slow tests in quick feedback cycles)",
        "Tags enforce code coverage thresholds",
        "Tags disable retries for flaky tests"
      ],
      "correct_answer_index": 1,
      "category": "Automation",
      "explanation": "Marking tests enables targeted subsets (fast vs slow, regression vs smoke), optimizing pipeline duration and focus.",
      "new": true
    },
    {
      "question": "What distinguishes a mock from a stub in testing terminology?",
      "options": [
        "Mocks and stubs are identical abstractions",
        "A stub provides canned responses; a mock also records interactions for behavioral verification",
        "A stub is dynamic; a mock is static",
        "Mocks can only be used in UI tests"
      ],
      "correct_answer_index": 1,
      "category": "Automation",
      "explanation": "Stubs supply predetermined data. Mocks add expectations/verification of method calls, arguments, and ordering to assert interactions.",
      "new": true
    },
    {
      "question": "Which approach most effectively reduces flakiness in UI tests?",
      "options": [
        "Increase all sleeps by 5 seconds",
        "Use explicit waits and stable locators; isolate non-deterministic dependencies (network, time) with mocks where possible",
        "Retry failed tests indefinitely",
        "Run tests only on fastest hardware"
      ],
      "correct_answer_index": 1,
      "category": "Automation",
      "explanation": "Deterministic waits plus resilient locators and isolation of variable external factors cut intermittent failures far better than arbitrary delays or blind retries.",
      "new": true
    },
    {
      "question": "When is it a good time to refactor test code?",
      "options": [
        "Only when all production features are complete",
        "When duplication, unclear intent, or brittle patterns appear, to maintain readability and reduce maintenance cost",
        "Never—refactoring tests risks masking product defects",
        "Only after code coverage exceeds 95%"
      ],
      "correct_answer_index": 1,
      "category": "Automation",
      "explanation": "Refactoring combats duplication and fragility, keeping the test suite sustainable and fast to evolve as the application changes.",
      "new": true
    },
    {
      "question": "In ISTQB terminology, what is the main purpose of acceptance testing?",
      "options": [
        "To evaluate system performance under load",
        "To verify the system meets user and business needs before deployment",
        "To integrate individual components into a working system",
        "To replace the need for regression testing"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Acceptance testing checks whether the system satisfies agreed user/business requirements and is ready for operational use (e.g. User, Operational, Contract, Regulatory)."
    },
    {
      "question": "Which statement best describes 'verification' versus 'validation'?",
      "options": [
        "Verification ensures the product is built right; validation ensures the right product is built",
        "Verification is dynamic; validation is static",
        "Validation applies only to performance tests",
        "There is no formal difference in ISTQB"
      ],
      "correct_answer_index": 0,
      "category": "ISTQB",
      "explanation": "Verification: are we building the product right (conformance to specs). Validation: are we building the right product (meets user needs)."
    },
    {
      "question": "What is the primary goal of regression testing?",
      "options": [
        "To confirm new code fixes the reported defect",
        "To ensure that changes have not introduced new defects in unchanged areas",
        "To validate acceptance criteria for a new feature",
        "To stress the system at boundary conditions"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Regression testing re-executes previously run tests to detect unintended side effects after changes (defect fixes, enhancements, environment changes)."
    },
    {
      "question": "Equivalence Partitioning is BEST used to...",
      "options": [
        "Test every possible input value individually",
        "Reduce the number of test cases by grouping inputs expected to behave similarly",
        "Prove 100% absence of defects",
        "Prioritize performance-related requirements"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Equivalence Partitioning divides input (or output) domains into classes expected to be treated the same, allowing representative test values and fewer cases."
    },
    {
      "question": "Boundary Value Analysis focuses on...",
      "options": [
        "Only typical (mid-range) values",
        "Values just at, below, and above the edges of equivalence classes",
        "Random sampling within large datasets",
        "Exploratory assessment of UI usability"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "BVA targets the extremes (min, max) and just inside/outside boundaries where off-by-one defects often occur."
    },
    {
      "question": "In ISTQB terms, what is a 'failure'?",
      "options": [
        "The human error that causes a problem",
        "A deviation of the software from expected behavior during execution",
        "The root cause found in the code",
        "A missing requirement in the specification"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Failure: observable deviation during execution. Defect/Fault: the flaw in the software. Error: human action leading to a defect."
    },
    {
      "question": "Which activity is characteristic of STATIC testing?",
      "options": [
        "Executing the system with test cases",
        "Reviewing requirements documents for ambiguity",
        "Running load tests to find scalability limits",
        "Performing exploratory sessions on the deployed app"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Static testing (reviews, walkthroughs, static analysis) examines artifacts without executing code to find defects early (ambiguities, omissions, style issues)."
    },
    {
      "question": "Risk-based testing prioritizes tests based on...",
      "options": [
        "Tester preference",
        "Module size only",
        "Impact and likelihood of potential failures",
        "The number of available automation tools"
      ],
      "correct_answer_index": 2,
      "category": "ISTQB",
      "explanation": "Risk = likelihood x impact. Higher risk areas get more/earlier testing effort to reduce product and project risk."
    },
    {
      "question": "What is an exit (completion) criterion for a test level?",
      "options": [
        "A condition that triggers defect creation",
        "A set of conditions that must be satisfied to declare testing for that level finished",
        "A mandatory automation framework requirement",
        "An informal note placed in source code"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Exit criteria define when testing can conclude (e.g., % coverage achieved, defect density below threshold, all high-priority defects resolved)."
    },
    {
      "question": "Root cause analysis aims to...",
      "options": [
        "Assign blame for the defect",
        "Identify the underlying source of a problem to prevent recurrence",
        "Increase the number of logged defects",
        "Replace functional testing entirely"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Root cause analysis looks beyond the symptom to prevent future occurrences (e.g., process gaps, misunderstanding of requirements)."
    },
    {
      "question": "Which test level focuses on verifying interactions between integrated components?",
      "options": [
        "Unit Testing",
        "Integration Testing",
        "System Testing",
        "Acceptance Testing"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Integration testing validates interfaces and interactions between combined units or components before full system testing." 
    },
    {
      "question": "What is a key benefit of test independence?",
      "options": [
        "Testers always find more defects than developers",
        "Reduced bias leading to more objective assessment of quality",
        "Eliminates the need for unit tests",
        "Guarantees zero defects in production"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Independent testers provide an unbiased view, increasing the chance of detecting issues developers may overlook." 
    },
    {
      "question": "Which test design technique is most appropriate when business rules are expressed as combinations of conditions producing actions?",
      "options": [
        "Boundary Value Analysis",
        "Decision Table Testing",
        "State Transition Testing",
        "Use Case Testing"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Decision tables model input conditions and resulting actions, ideal for complex business rule combinations." 
    },
    {
      "question": "State Transition Testing is BEST applied when...",
      "options": [
        "Inputs map to discount percentages",
        "There is navigation across independent pages only",
        "The system behavior changes based on previous events",
        "Only arithmetic calculations are performed"
      ],
      "correct_answer_index": 2,
      "category": "ISTQB",
      "explanation": "State transition testing targets systems whose output depends on prior states (e.g. login attempts, workflow progression)." 
    },
    {
      "question": "Error Guessing relies primarily on...",
      "options": [
        "Formal specification coverage",
        "Tester experience and intuition",
        "Mathematical input partitioning",
        "Tool-assisted static analysis"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Error Guessing is an experience-based technique where testers anticipate likely defect areas from past patterns." 
    },
    {
      "question": "Exploratory Testing is characterized by...",
      "options": [
        "Pre-scripted test cases only",
        "Simultaneous learning, test design, and execution",
        "Exclusive use of automation frameworks",
        "Formal traceability to every requirement before execution"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Exploratory testing blends learning and dynamic test design during execution to probe areas not fully specified." 
    },
    {
      "question": "Which document defines the overall approach for testing across the organization or product line?",
      "options": [
        "Test Plan",
        "Test Strategy",
        "Defect Report",
        "Release Notes"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "A test strategy sets high-level principles and approaches; a test plan operationalizes these for a specific project or release." 
    },
    {
      "question": "A key purpose of a Requirements Traceability Matrix (RTM) is to...",
      "options": [
        "Measure execution time of each test",
        "Map requirements to test cases ensuring coverage",
        "Rank defects by severity",
        "Eliminate redundant code paths"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Traceability matrices link requirements to design, test cases, and outcomes to demonstrate coverage and identify gaps." 
    },
    {
      "question": "Which is a typical Test Closure activity?",
      "options": [
        "Defining entry criteria",
        "Designing new test cases",
        "Archiving testware and analyzing lessons learned",
        "Executing regression tests for a new sprint"
      ],
      "correct_answer_index": 2,
      "category": "ISTQB",
      "explanation": "Closure includes collecting testware, summarizing results, evaluating exit criteria, and documenting lessons learned." 
    },
    {
      "question": "Alpha testing is conducted...",
      "options": [
        "Externally by end-users only",
        "Internally at the developer's site before public release",
        "After beta testing concludes",
        "Only for performance benchmarking"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Alpha testing occurs at the developer site with internal or limited external participants prior to broader beta release." 
    },
    {
      "question": "Beta testing is typically performed to...",
      "options": [
        "Replace system testing",
        "Collect real-world feedback from external users in operational environments",
        "Guarantee zero known defects at release",
        "Validate unit test coverage"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Beta testing exposes the product to external users to gather usability and reliability feedback in realistic contexts." 
    },
    {
      "question": "Maintenance testing is triggered MOST often by...",
      "options": [
        "Daily stand-up meetings",
        "Changes like patches, migrations, or environment updates",
        "Unit test failures only",
        "Database backups"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Maintenance testing validates that updates (defect fixes, environment upgrades, data migrations) haven't harmed existing functionality." 
    },
    {
      "question": "Risk likelihood refers to...",
      "options": [
        "The severity of user impact",
        "The probability the failure will occur",
        "The number of executed test cases",
        "The cost of mitigating a defect"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Risk combines likelihood (probability of occurrence) and impact (consequence if it occurs). Both guide prioritization." 
    },
    {
      "question": "Which metric helps monitor test progress effectively?",
      "options": [
        "Number of developer code commits",
        "Percentage of planned test cases executed",
        "Lines of code per module",
        "CPU utilization at runtime"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Execution progress metrics (e.g., % executed, pass/fail counts, defect discovery rate) support monitoring and control." 
    },
    {
      "question": "Dynamic testing differs from static testing because it...",
      "options": [
        "Inspects artifacts without running code",
        "Executes code to observe behavior",
        "Cannot find runtime failures",
        "Requires only informal reviews"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Dynamic testing involves executing software to evaluate outcomes; static testing analyzes artifacts without execution." 
    },
    {
      "question": "Decision table testing is MOST useful when...",
      "options": [
        "System response depends on multiple condition combinations",
        "Only numeric boundary conditions exist",
        "User interface layout is unstable",
        "Memory leaks must be detected"
      ],
      "correct_answer_index": 0,
      "category": "ISTQB",
      "explanation": "Decision tables clarify complex combinations of conditions and corresponding actions, supporting thorough coverage of rule sets." 
    },
    {
      "question": "Pairwise (all-pairs) testing primarily reduces...",
      "options": [
        "Total combinations needing execution while retaining defect detection for interaction faults",
        "Defect severity",
        "Need for boundary tests",
        "Traceability documentation"
      ],
      "correct_answer_index": 0,
      "category": "ISTQB",
      "explanation": "Pairwise testing selects cases covering all possible pairs of parameter values, shrinking test count while exposing many interaction defects." 
    },
    {
      "question": "What BEST describes regression test selection after a change?",
      "options": [
        "Retest only the modified lines",
        "Retest changed areas plus impacted functionality based on dependency analysis",
        "Skip previously passing tests",
        "Execute performance tests only"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Effective regression selection targets changed code and related areas likely influenced by the modification (data flows, interfaces)." 
    },
    {
      "question": "Which is an example of a non-functional test type?",
      "options": [
        "Boundary value test",
        "Usability test",
        "Decision table test",
        "Equivalence partition test"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Non-functional testing addresses attributes like usability, performance, reliability, and security." 
    },
    {
      "question": "Shift-left testing emphasizes...",
      "options": [
        "Delaying tests until after deployment",
        "Starting testing earlier in the lifecycle to detect defects sooner",
        "Only automating UI tests",
        "Removing unit tests entirely"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Shift-left moves test activities earlier (requirements/design/unit) to reduce late defect discovery costs." 
    },
    {
      "question": "An INCIDENT report (defect report) typically includes...",
      "options": [
        "Future sprint capacity",
        "Steps to reproduce, observed vs expected results, and severity",
        "Complete source code diff",
        "List of all past releases"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Incident reports capture reproducible steps, environment, observed behavior, expected behavior, classification (severity/priority)." 
    },
    {
      "question": "Test monitoring differs from test control by...",
      "options": [
        "Control collects status; monitoring reacts to deviations",
        "Monitoring collects status; control applies corrective actions",
        "They are identical in scope",
        "Monitoring only applies after closure"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Monitoring gathers status metrics; control uses that data to steer activities (reallocation, re-planning)." 
    },
    {
      "question": "Which activity is NOT part of static testing?",
      "options": [
        "Code walkthrough",
        "Requirements review",
        "Unit test execution",
        "Design inspection"
      ],
      "correct_answer_index": 2,
      "category": "ISTQB",
      "explanation": "Static testing examines artifacts (requirements, design, code) without executing them. Unit test execution is dynamic testing." 
    },
    {
      "question": "Which review type is the MOST formal and typically follows a defined entry/exit criteria with logged defects?",
      "options": [
        "Informal review",
        "Walkthrough",
        "Technical review",
        "Inspection"
      ],
      "correct_answer_index": 3,
      "category": "ISTQB",
      "explanation": "Inspections are highly formal with defined roles (moderator, reader, author, scribe), checklists, metrics, and documented defects." 
    },
    {
      "question": "Which maintenance type involves adapting software to changes in its environment (e.g., new OS version)?",
      "options": [
        "Corrective maintenance",
        "Adaptive maintenance",
        "Perfective maintenance",
        "Preventive maintenance"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Adaptive maintenance modifies the product to remain usable in a changed environment (platform, regulations)." 
    },
    {
      "question": "Improving performance and maintainability without adding new functionality BEST describes...",
      "options": [
        "Corrective maintenance",
        "Adaptive maintenance",
        "Perfective maintenance",
        "Emergency maintenance"
      ],
      "correct_answer_index": 2,
      "category": "ISTQB",
      "explanation": "Perfective maintenance enhances quality attributes (performance, usability, maintainability) of existing functionality." 
    },
    {
      "question": "Which maintenance type aims to reduce the probability of future failures by refactoring or removing latent defects?",
      "options": [
        "Preventive maintenance",
        "Corrective maintenance",
        "Perfective maintenance",
        "Adaptive maintenance"
      ],
      "correct_answer_index": 0,
      "category": "ISTQB",
      "explanation": "Preventive maintenance anticipates issues (e.g., refactoring risky modules) to prevent future failures." 
    },
    {
      "question": "Which SDLC phase typically provides the primary test basis for System Testing?",
      "options": [
        "Unit design specifications",
        "Component implementation details",
        "Requirements and functional specifications",
        "Deployment scripts"
      ],
      "correct_answer_index": 2,
      "category": "ISTQB",
      "explanation": "System testing validates the whole system against requirements, use cases, functional and non-functional specifications." 
    },
    {
      "question": "Which sequence BEST represents high-level STLC (Software Testing Life Cycle) activities?",
      "options": [
        "Test planning -> Test analysis & design -> Environment setup -> Test execution -> Reporting -> Closure",
        "Test execution -> Planning -> Design -> Closure -> Analysis",
        "Design -> Closure -> Planning -> Execution",
        "Planning -> Coding -> Execution -> Release"
      ],
      "correct_answer_index": 0,
      "category": "ISTQB",
      "explanation": "Typical STLC flow: Planning, Analysis & Design, Environment/Setup, Implementation (testware), Execution, Reporting/Monitoring, Closure." 
    },
    {
      "question": "Statement coverage measures...",
      "options": [
        "Percentage of decision outcomes exercised",
        "Percentage of executable statements executed",
        "Percentage of all possible paths executed",
        "Percentage of requirements traced to tests"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Statement coverage counts executed statements vs total executable statements, indicating breadth of basic code execution." 
    },
    {
      "question": "Branch (decision) coverage requires...",
      "options": [
        "Each boolean sub-condition be True and False",
        "Each possible path through the code be taken",
        "Each decision (e.g., if, switch) have all outcomes executed at least once",
        "Each loop iterate maximum times"
      ],
      "correct_answer_index": 2,
      "category": "ISTQB",
      "explanation": "Branch (decision) coverage ensures every decision outcome (True/False or each case) executes at least once." 
    },
    {
      "question": "Condition coverage differs from decision coverage by requiring...",
      "options": [
        "Every individual atomic condition within a decision evaluates both True and False",
        "All paths be executed",
        "No unreachable code exist",
        "All loops reach boundary values"
      ],
      "correct_answer_index": 0,
      "category": "ISTQB",
      "explanation": "Condition coverage targets each atomic boolean expression inside composite decisions separately (True & False)." 
    },
    {
      "question": "Path coverage is often impractical because...",
      "options": [
        "It cannot find defects",
        "The number of paths can grow exponentially with loops and branches",
        "It ignores decisions",
        "It requires only manual testing"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Path coverage attempts to execute all distinct execution paths; loops and nested branches make paths explode combinatorially." 
    },
    {
      "question": "Which coverage level conceptually subsumes statement and branch coverage?",
      "options": [
        "Condition coverage",
        "Path coverage",
        "Requirements coverage",
        "Error guessing"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "If all execution paths are covered, every statement and branch is necessarily exercised (though full path coverage is rarely feasible)." 
    },
    {
      "question": "Which is the BEST example of an exit criterion?",
      "options": [
        "Start executing high priority test cases",
        "90% statement coverage achieved with all high severity defects fixed",
        "Assign testers to new features",
        "Begin defect triage meetings"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Exit criteria are conditions to conclude testing (e.g., coverage thresholds met, critical defects resolved, residual risk acceptable)." 
    },
    {
      "question": "A common metric used to assess readiness against exit criteria is...",
      "options": [
        "Number of lines of code added",
        "Defect density in executed modules",
        "Developer satisfaction score",
        "Time spent in code reviews"
      ],
      "correct_answer_index": 1,
      "category": "ISTQB",
      "explanation": "Defect density (defects per size unit or per function point) helps evaluate residual risk vs exit criteria thresholds." 
    }
    ,
    {
      "question": "In a layered automated test strategy, which test type typically provides the fastest feedback with the highest isolation of failures?",
      "options": [
        "Unit tests",
        "End-to-end UI tests",
        "Exploratory tests",
        "User acceptance tests"
      ],
      "correct_answer_index": 0,
      "category": "Automation",
      "explanation": "Unit tests execute small, isolated code units in-memory without external dependencies, giving very fast, precise feedback on defects.",
      "new": true
    },
    {
      "question": "What is the primary advantage of emphasizing API/service-level tests over UI tests in an automation suite?",
      "options": [
        "They require no maintenance once written",
        "They eliminate the need for any UI testing",
        "They are faster and less brittle, providing earlier detection of logic or contract defects",
        "They automatically generate complete performance metrics"
      ],
      "correct_answer_index": 2,
      "category": "Automation",
      "explanation": "API tests bypass fragile presentation layers, run quickly, and validate business logic and contracts early—reducing reliance on slower, brittle UI tests.",
      "new": true
    },
    {
      "question": "In pytest, why would you use a session-scoped fixture for initializing an expensive external dependency (e.g., a Dockerized service)?",
      "options": [
        "To force each test to recreate the dependency for isolation",
        "To ensure the dependency persists across all tests, amortizing setup cost",
        "Because session scope disables teardown logic",
        "It automatically parallelizes all tests using the fixture"
      ],
      "correct_answer_index": 1,
      "category": "Automation",
      "explanation": "Session-scoped fixtures initialize once per test session, dramatically reducing redundant costly setup while still allowing controlled teardown.",
      "new": true
    },
    {
      "question": "Which strategy MOST effectively keeps automated test data deterministic across runs?",
      "options": [
        "Reusing and mutating shared data created by previous test executions",
        "Generating random data without any seeding policy",
        "Resetting the environment and loading a known seeded dataset before the suite starts",
        "Hardcoding dynamic identifiers directly in test scripts"
      ],
      "correct_answer_index": 2,
      "category": "Automation",
      "explanation": "A clean environment plus a known seeded dataset removes hidden dependencies and flakiness caused by residual or randomized state.",
      "new": true
    },
    {
      "question": "What distinguishes Continuous Delivery from Continuous Deployment in an automated pipeline?",
      "options": [
        "Continuous Delivery automatically deploys every commit straight to production",
        "Continuous Deployment requires manual packaging while Delivery skips testing",
        "Continuous Delivery ensures every change is always in a deployable state; Continuous Deployment actually releases each change automatically",
        "There is no practical difference; the terms are interchangeable"
      ],
      "correct_answer_index": 2,
      "category": "Automation",
      "explanation": "Continuous Delivery keeps software releasable at all times with automated quality gates; Continuous Deployment takes the final step of automatically releasing each passed change to production.",
      "new": true
    }
  ]