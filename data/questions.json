[
  {
    "question": "Given the following Python code, what will be printed if the element with the ID 'submit-btn' is found and enabled on the page?",
    "code_snippet": "from selenium.webdriver.common.by import By\n\ntry:\n    button = driver.find_element(By.ID, 'submit-btn')\n    if button.is_enabled():\n        print('Button is ready')\n    else:\n        print('Button is not interactable')\nexcept:\n    print('Button not found')",
    "options": [
      "Button is ready",
      "Button is not interactable",
      "Button not found",
      "The code will raise an exception"
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "When the element is found and enabled, the condition button.is_enabled() evaluates to True, executing the print statement 'Button is ready'. The code only prints the other messages if the element is disabled or not found."
  },
  {
    "question": "Which line of Python code correctly initializes a WebDriverWait instance with a 10-second timeout?",
    "options": [
      "wait = WebDriverWait(10, driver)",
      "wait = WebDriverWait(driver, 10)",
      "wait = driver.wait(10)",
      "wait = WebDriverWait.create(driver, 10)"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "WebDriverWait(driver, 10) correctly initializes an explicit wait with a 10-second timeout, where driver is passed first."
  },
  {
    "question": "In Selenium, what is the primary purpose of the `By` class?",
    "options": [
      "To perform browser actions like click() and send_keys()",
      "To manage browser windows and tabs",
      "To provide mechanisms for locating elements on a page (e.g., by ID, Name, XPath)",
      "To store test data"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The By class defines locator strategies (By.ID, By.NAME, By.XPATH, By.CSS_SELECTOR, etc.) that tell Selenium how to find elements in the DOM. It doesn't perform actions, manage windows, or store data."
  },
  {
    "question": "What is the primary benefit of using the Page Object Model (POM) in test automation?",
    "options": [
      "To make test execution significantly faster",
      "To separate test case logic from UI interaction logic, making tests more maintainable and less brittle to UI changes",
      "To automatically generate test data for the application",
      "To replace the need for a testing framework like JUnit or TestNG"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "POM separates test logic from UI structure, making maintenance easier when the UI changes."
  },
  {
    "question": "In the context of testing frameworks like pytest, what is the primary role of a fixture?",
    "options": [
      "To store and parameterize test data, allowing a single test to run with multiple inputs",
      "To perform the assertions or checks that determine if a test passes or fails",
      "To provide a fixed baseline for tests, managing setup and teardown logic",
      "To generate detailed reports and logs of test execution"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Fixtures in pytest handle setup and teardown logic, providing a consistent baseline for tests."
  },
  {
    "question": "In Selenium, which locator strategy is best suited to handle elements with dynamic IDs?",
    "options": [
      "By.ID",
      "By.CLASS_NAME",
      "XPath or CSS Selector",
      "By.NAME"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The By class provides mechanisms to locate web elements, like ID, name, or XPath."
  },
  {
    "question": "What's the best approach for managing test configuration?",
    "options": [
      "Hardcoding values directly in test scripts",
      "Storing configuration in a dedicated test database",
      "Using environment variables",
      "Using external configuration files that can be overridden by environment variables"
    ],
    "correct_answer_index": 3,
    "category": "Automation",
    "explanation": "Using external configuration files (JSON, YAML, INI) provides flexibility and maintainability, while environment variables allow overriding settings for different environments (dev, test, prod) without changing code."
  },
  {
    "question": "What's the best way to handle dynamic table content?",
    "options": [
      "Using absolute XPath to navigate the table structure",
      "Relying on fixed row and column indexes",
      "Locating table rows based on unique text in a specific column",
      "Getting all rows and iterating with a loop"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Using unique text content in a column provides a stable locator even when table structure changes. Absolute XPath and fixed indexes are brittle and break when content changes. Iterating all rows is inefficient and requires more complex logic."
  },
  {
    "question": "What's the output of `print(1 + \"2\" - 1)` in Python?",
    "options": [
      "2",
      "\"12-1\"",
      "0",
      "A TypeError will be raised"
    ],
    "correct_answer_index": 3,
    "category": "Python",
    "explanation": "Mixing integers and strings in arithmetic operations raises a TypeError in Python."
  },
  {
    "question": "Which of the following completes the code `current_url = driver.______` to get the current URL of the page in Selenium?",
    "options": [
      "get_current_url()",
      "current_url",
      "url",
      "page_source"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.current_url retrieves the current page’s URL as a string."
  },
  {
    "question": "In Python's unittest framework, what method is used to assert that two values are equal?",
    "options": [
      "assert_equals(a, b)",
      "assertTrue(a == b)",
      "assertEqual(a, b)",
      "assert(a == b)"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "assertEqual(a, b) is the standard unittest method to compare expected and actual values."
  },
  {
    "question": "What's the output of `print(5 == \"5\")` in Python?",
    "options": [
      "True",
      "False",
      "A TypeError will be raised",
      "A SyntaxError will be raised"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Python does not perform type coercion with the == operator. The integer 5 and string \"5\" are different types and values, so the comparison returns False."
  },
  {
    "question": "What is the correct method to launch a browser in Selenium using Python?",
    "options": [
      "start_browser()",
      "get()",
      "launch()",
      "open()"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.get('url') is the standard Selenium WebDriver method used to navigate to a specified URL. It loads the page and waits for it to complete loading before continuing script execution."
  },
  {
    "question": "What is the best and most idiomatic way of handling exceptions in Python?",
    "options": [
      "Using if-else conditional blocks",
      "try-catch blocks",
      "Using specific try-except blocks",
      "Ignoring exceptions to prevent crashes"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Using specific try-except blocks (e.g., except ValueError, except FileNotFoundError) allows precise error handling, better debugging, and prevents accidentally catching unexpected exceptions that should propagate."
  },
  {
    "question": "In general, what is the best practice for handling unexpected errors (e.g., an element not found) during the execution of an automated functional test?",
    "options": [
      "The error should be logged, and the test should continue to execute subsequent steps.",
      "The script should use a try-except block to catch and ignore the error, allowing the test to pass.",
      "The test should fail immediately at the point of the error, clearly reporting the cause.",
      "The test should pause and wait for manual intervention to fix the issue before continuing."
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "Tests should fail fast to provide immediate, actionable feedback. Continuing after errors can cascade into false positives/negatives and obscure the root cause. Clear failure reports enable quick debugging."
  },
  {
    "question": "What is the most reliable method to specifically wait for an element to become visible on a web page before interacting with it?",
    "options": [
      "Using driver.implicitly_wait(10) at the start of the test.",
      "Using WebDriverWait with ExpectedConditions.presence_of_element_located()",
      "Using WebDriverWait with ExpectedConditions.visibility_of_element_located()",
      "Using a static time.sleep(5) before the element interaction."
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "visibility_of_element_located() waits for the element to be both present in the DOM and visible (not hidden). presence_of_element_located() only checks DOM presence, not visibility. Static sleeps waste time and are unreliable."
  },
  {
    "question": "Given the following Python code, what will be printed to the console?",
    "code_snippet": "my_set = {1, 2, 3}\nmy_set.add(3)\nmy_set.add(4)\nprint(len(my_set))",
    "options": [
      "3",
      "4",
      "5",
      "The code will raise an exception"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Sets automatically ignore duplicate values. Adding 3 again has no effect since it's already in the set. After adding 4, the set contains {1, 2, 3, 4}, so len() returns 4."
  },
  {
    "question": "In Selenium, how can you execute a piece of JavaScript code within the context of the current page?",
    "options": [
      "driver.run_javascript('alert(\"hello\")')",
      "driver.execute_script('alert(\"hello\")')",
      "driver.javascript('alert(\"hello\")')",
      "driver.inject_script('alert(\"hello\")')"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.execute_script() is the Selenium method for running JavaScript in the browser context. This is useful for interacting with elements not directly accessible via Selenium's API or for custom actions."
  },
  {
    "question": "In the context of test automation, what is the main purpose of a 'smoke test' suite?",
    "options": [
      "To perform in-depth testing of a specific feature.",
      "To verify that the most critical functionalities of the application are working after a new build, before more extensive testing is done.",
      "To test the application under heavy load to identify performance bottlenecks.",
      "To run all regression tests to ensure new changes haven't broken existing functionality."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Smoke tests are quick, high-level checks that verify the application is stable enough for further testing. They catch major breaks early, saving time by preventing full test suite runs on broken builds."
  },
  {
    "question": "What is the correct way to switch to an iframe with the name 'my_frame' in Selenium?",
    "code_snippet": "from selenium.webdriver.remote.webdriver import WebDriver\n\ndriver: WebDriver\n# Assume driver is initialized\n# How to switch to the iframe?",
    "options": [
      "driver.switch_to(frame='my_frame')",
      "driver.switch_to_iframe('my_frame')",
      "driver.switch_to.frame('my_frame')",
      "driver.select_frame('my_frame')"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "Use driver.switch_to.frame('my_frame') to target a specific frame by name or ID."
  },
  {
    "question": "Which of the following correctly uses an f-string in Python for string formatting?",
    "options": [
      "name = 'World'\nprint('Hello, {name}')",
      "name = 'World'\nprint(f'Hello, {name}')",
      "name = 'World'\nprint('Hello, %s' % name)",
      "name = 'World'\nprint('Hello, {}'.format(name))"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "F-strings (formatted string literals) use the 'f' prefix before the string and evaluate expressions inside curly braces {}. They are the modern, most readable way to format strings in Python 3.6+."
  },
  {
    "question": "In test automation, what is a 'flaky' test?",
    "options": [
      "A test that is designed to always fail to check the reporting system.",
      "A test that passes and fails intermittently without any changes to the code or the test environment.",
      "A test that takes a very long time to execute.",
      "A test that covers a non-critical feature of the application."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "A flaky test passes or fails inconsistently without code changes, often due to timing or environment."
  },
  {
    "question": "How do you perform a right-click action on an element using Selenium's ActionChains?",
    "code_snippet": "from selenium.webdriver.common.action_chains import ActionChains\n\n# Assume 'driver' and 'element' are defined\n\n# How to perform a right-click?",
    "options": [
      "ActionChains(driver).right_click(element).perform()",
      "ActionChains(driver).context_click(element).perform()",
      "ActionChains(driver).click(element, 'right').perform()",
      "element.right_click()"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "ActionChains(driver).context_click(element).perform() performs a right-click on the element."
  },
  {
    "question": "What is the primary difference between a Python list and a tuple?",
    "options": [
      "Lists can store items of different data types, while tuples can only store items of the same type.",
      "Lists are mutable (changeable), while tuples are immutable (unchangeable).",
      "Lists use square brackets `[]`, while tuples use curly braces `{}`.",
      "Lists are ordered and indexed, while tuples are unordered."
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Lists can be modified after creation (add, remove, change items), while tuples cannot be changed once created. Use tuples for data that shouldn't change, and lists for dynamic collections."
  },
  {
    "question": "What is the purpose of the `finally` block in a Python `try...except` statement?",
    "options": [
      "It contains the code that will be executed only if an exception occurs.",
      "It is where you define the custom exception to be raised.",
      "It contains the code that will be executed only if no exception occurs.",
      "It contains the code that will be executed regardless of whether an exception occurred or not."
    ],
    "correct_answer_index": 3,
    "category": "Python",
    "explanation": "The finally block always executes, making it ideal for cleanup operations like closing files, releasing resources, or logging. It runs whether an exception occurs or not, and even if there's a return statement."
  },
  {
    "question": "Which of the following is NOT a valid Selenium locator strategy in the `By` class?",
    "options": [
      "By.XPATH",
      "By.CSS_SELECTOR",
      "By.TAG_NAME",
      "By.JQUERY_SELECTOR"
    ],
    "correct_answer_index": 3,
    "category": "Selenium",
    "explanation": "By.JQUERY_SELECTOR is not a valid locator strategy in Selenium's By class. The valid strategies include ID, NAME, XPATH, CSS_SELECTOR, CLASS_NAME, TAG_NAME, LINK_TEXT, and PARTIAL_LINK_TEXT."
  },
  {
    "question": "In a Behavior-Driven Development (BDD) framework using Gherkin, what is the purpose of the 'Given', 'When', 'Then' keywords?",
    "options": [
      "To define Python functions for the test.",
      "To structure the test in a human-readable format describing a feature's behavior from a user's perspective.",
      "To import necessary libraries and modules for the test.",
      "To set the priority and order of test execution."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Gherkin's Given-When-Then syntax creates human-readable test scenarios: Given sets preconditions, When describes actions, Then verifies outcomes. This bridges communication between technical and non-technical stakeholders."
  },
  {
    "question": "What will be the output of the following Python list comprehension?",
    "code_snippet": "squares = [x * x for x in range(5)]\nprint(squares)",
    "options": [
      "[1, 4, 9, 16, 25]",
      "[0, 1, 4, 9, 16]",
      "[0, 1, 2, 3, 4]",
      "The code will raise a syntax error."
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "List comprehensions provide a compact way to generate lists; range(5) gives 0–4, so squares are [0, 1, 4, 9, 16]."
  },
  {
    "question": "What is the key difference between `driver.find_element()` and `driver.find_elements()` in Selenium?",
    "options": [
      "`find_element()` returns the first matching element or raises an exception if not found, while `find_elements()` returns a list of all matching elements or an empty list if none are found.",
      "`find_element()` is used for single elements and `find_elements()` is for multiple, but both raise an exception if no elements are found.",
      "`find_element()` returns a single WebElement, while `find_elements()` returns a generator object.",
      "There is no functional difference; `find_elements()` is just an alias for `find_element()`."
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "find_element() expects exactly one match and raises NoSuchElementException if not found. find_elements() returns a list (empty if no matches), which is safer when you're unsure if elements exist or need to check multiple matches."
  },
  {
    "question": "In Python, what is the primary difference between accessing a dictionary value with `my_dict['key']` versus `my_dict.get('key')`?",
    "options": [
      "They are identical; `.get()` is just a more verbose way of doing the same thing.",
      "`my_dict['key']` is faster, but `my_dict.get('key')` can provide a default value if the key is not found.",
      "`my_dict['key']` will raise a `KeyError` if the key does not exist, whereas `my_dict.get('key')` will return `None` by default.",
      "`my_dict['key']` can only be used for string keys, while `.get()` works with any hashable type."
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Bracket notation my_dict['key'] raises KeyError for missing keys, requiring exception handling. The .get() method returns None (or a specified default) for missing keys, making code more defensive and readable."
  },
  {
    "question": "What is the purpose of a Python virtual environment?",
    "options": [
      "To run Python scripts with elevated administrator privileges securely.",
      "To create a simulated operating system for testing cross-platform compatibility.",
      "To create an isolated environment with its own set of packages and dependencies, separate from the system-wide Python installation.",
      "To improve the performance of Python scripts by pre-compiling them to machine code."
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Virtual environments isolate Python dependencies from the system installation for cleaner management."
  },
  {
    "question": "What is the most common cause of a `StaleElementReferenceException` in Selenium?",
    "options": [
      "The browser window has been resized, invalidating element coordinates.",
      "The element was located, but the DOM was updated (e.g., via AJAX or page navigation) before the script could interact with it.",
      "The wrong locator strategy was used, so the element was never correctly identified.",
      "The browser's cache was cleared during the test run."
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "A StaleElementReferenceException occurs when the DOM updates after locating the element."
  },
  {
    "question": "What is regression testing in the context of software quality assurance?",
    "options": [
      "Testing a new feature to ensure it meets all specified requirements.",
      "The process of re-running existing tests to ensure that recent code changes have not introduced new bugs or broken existing functionality.",
      "A type of performance testing to see how the application degrades under heavy load.",
      "Manual testing performed by end-users to find usability issues."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Regression testing re-runs existing tests to confirm that new changes didn’t break old functionality."
  },
  {
    "question": "In pytest, what is the primary purpose of the `@pytest.mark.parametrize` decorator?",
    "options": [
      "To mark a test as belonging to a specific group or category.",
      "To run the same test function multiple times with different sets of arguments.",
      "To skip a test if a certain condition is not met.",
      "To specify a dependency, ensuring one test runs before another."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "@pytest.mark.parametrize allows data-driven testing by running the same test with different input values. Each parameter set creates a separate test case, improving coverage without code duplication."
  },
  {
    "question": "Given the following Python code, what is the output of `my_function(1, 2, c=3, d=4)`?",
    "code_snippet": "def my_function(a, b, *args, **kwargs):\n    print(f\"a={a}, b={b}, args={args}, kwargs={kwargs}\")",
    "options": [
      "a=1, b=2, args=(), kwargs={'c': 3, 'd': 4}",
      "a=1, b=2, args=(3, 4), kwargs={}",
      "The code will raise a TypeError because of unexpected keyword arguments.",
      "a=1, b=2, c=3, d=4, args=(), kwargs={}"
    ],
    "correct_answer_index": 0,
    "category": "Python",
    "explanation": "Positional arguments 1 and 2 are assigned to a and b. Since no extra positional args are provided, args is an empty tuple. Named arguments c=3 and d=4 are captured in the kwargs dictionary."
  },
  {
    "question": "Which Selenium method is generally preferred for clearing text from an input field before typing new text?",
    "options": [
      "Sending the backspace key repeatedly with `send_keys()`.",
      "Executing a JavaScript command to set the element's value to an empty string.",
      "Using the `.clear()` method on the web element.",
      "Using `send_keys(\"\")` to send an empty string."
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The clear() method empties an input field before sending new text, ensuring clean entry."
  },
  {
    "question": "What is a Python lambda function?",
    "options": [
      "A standard function defined with the `def` keyword that is stored in a special, faster memory location.",
      "A small, anonymous, single-expression function defined with the `lambda` keyword.",
      "A function that can only be used within a class definition.",
      "A built-in function for running code in parallel."
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "A lambda defines an anonymous single-expression function; here, it filters even numbers."
  },
  {
    "question": "How can you take a screenshot of the current browser window in Selenium?",
    "options": [
      "driver.get_screenshot()",
      "driver.save_screenshot('my_screenshot.png')",
      "driver.take_screenshot(file='my_screenshot.png')",
      "driver.capture_screen('my_screenshot.png')"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.save_screenshot('filename.png') captures the current browser viewport and saves it to the specified file path. This is invaluable for debugging test failures and documenting test execution."
  },
  {
    "question": "In test automation, what does the principle of 'Data-Driven Testing' refer to?",
    "options": [
      "Testing how the application handles large volumes of data.",
      "A method where test data is stored in a database and queried during test execution.",
      "An approach where test logic is separated from the test data, allowing the same test script to be executed with multiple data sets, often read from an external source (like a spreadsheet or CSV file).",
      "Automatically generating random data to use as input for tests."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Data-driven testing separates test logic from input data, running the same test with multiple datasets."
  },
  {
    "question": "What will be printed to the console by the following Python code?",
    "code_snippet": "data = [1, 2, 3, 4, 5]\nresult = list(filter(lambda x: x % 2 == 0, data))\nprint(result)",
    "options": [
      "[1, 3, 5]",
      "[2, 4]",
      "The code will raise a TypeError.",
      "[False, True, False, True, False]"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "The filter() function applies the lambda to each element, keeping only those where x % 2 == 0 (even numbers). This filters [1,2,3,4,5] to [2,4]."
  },
  {
    "question": "Which code snippet correctly performs a 'drag and drop' action in Selenium?",
    "options": [
      "ActionChains(driver).click(source).release(target).perform()",
      "ActionChains(driver).drag(source, target).perform()",
      "ActionChains(driver).drag_and_drop(source, target).perform()",
      "ActionChains(driver).move_to_element(source).click_and_hold().move_to_element(target).release().perform()"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "ActionChains(driver).drag_and_drop(source, target).perform() is the concise, idiomatic way to drag an element from source to target. It handles the click-hold-move-release sequence automatically."
  },
  {
    "question": "What is the output of the following Python code?",
    "code_snippet": "my_list = ['a', 'b', 'c', 'd', 'e']\nremoved_item = my_list.pop(2)\nprint(removed_item, my_list)",
    "options": [
      "b ['a', 'c', 'd', 'e']",
      "c ['a', 'b', 'd', 'e']",
      "d ['a', 'b', 'c', 'e']",
      "None ['a', 'b', 'd', 'e']"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "list.pop(2) removes and returns the element at index 2 (zero-based), which is 'c'. The list is modified in place, leaving ['a', 'b', 'd', 'e']."
  },
  {
    "question": "Complete the following Selenium code to wait until an element is clickable.",
    "code_snippet": "from selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\n\nwait = WebDriverWait(driver, 10)\nelement = wait.until(EC.______( (By.ID, 'submit-btn') ))",
    "options": [
      "visibility_of_element_located",
      "presence_of_element_located",
      "element_to_be_clickable",
      "element_to_be_selected"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "element_to_be_clickable waits until the element is both visible and enabled, ensuring it can actually be clicked. This prevents ElementNotInteractableException errors."
  },
  {
    "question": "Which line of code is required to make a hidden menu visible by hovering the mouse over its parent element?",
    "code_snippet": "from selenium.webdriver.common.action_chains import ActionChains\n\nmenu_trigger = driver.find_element(By.ID, 'menu-trigger')\n# Missing code here to make the menu appear\n",
    "options": [
      "ActionChains(driver).hover(menu_trigger).perform()",
      "ActionChains(driver).move_to_element(menu_trigger).perform()",
      "driver.execute_script('arguments[0].hover();', menu_trigger)",
      "menu_trigger.hover()"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "ActionChains(driver).move_to_element(menu_trigger).perform() simulates hovering the mouse over an element, which triggers CSS :hover effects and reveals hidden menus."
  },
  {
    "question": "What will be printed after running this Python code?",
    "code_snippet": "numbers = [1, 2, 3, 4, 5]\nnew_list = [n * 2 for n in numbers if n % 2 != 0]\nprint(new_list)",
    "options": [
      "[2, 4, 6, 8, 10]",
      "[1, 3, 5]",
      "[4, 10]",
      "[2, 6, 10]"
    ],
    "correct_answer_index": 3,
    "category": "Python",
    "explanation": "The comprehension filters for odd numbers (n % 2 != 0), giving [1, 3, 5], then multiplies each by 2, resulting in [2, 6, 10]."
  },
  {
    "question": "Fill in the blank to complete the code that checks if a checkbox is selected.",
    "code_snippet": "checkbox = driver.find_element(By.ID, 'terms-and-conditions')\nif checkbox.______:\n    print('Checkbox is already selected.')",
    "options": [
      "is_selected()",
      "is_checked()",
      "get_attribute('selected')",
      "is_enabled()"
    ],
    "correct_answer_index": 0,
    "category": "Automation",
    "explanation": "is_selected() is a method that returns True if a checkbox, radio button, or option is selected, and False otherwise. Note the parentheses—it's a method, not a property."
  },
  {
    "question": "How do you correctly use ActionChains to press the SHIFT key, type 'hello', and then release the SHIFT key?",
    "options": [
      "ActionChains(driver).press(Keys.SHIFT).send_keys('hello').release(Keys.SHIFT).perform()",
      "ActionChains(driver).key_down(Keys.SHIFT).send_keys('hello').key_up(Keys.SHIFT).perform()",
      "ActionChains(driver).send_keys(Keys.SHIFT, 'hello').perform()",
      "ActionChains(driver).send_keys_with_modifier(Keys.SHIFT, 'hello').perform()"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "key_down() presses and holds a modifier key, send_keys() types text while it's held, and key_up() releases it. This pattern simulates holding SHIFT while typing, resulting in 'HELLO'."
  },
  {
    "question": "What is the output of this Python code snippet that uses list slicing?",
    "code_snippet": "letters = ['a', 'b', 'c', 'd', 'e', 'f']\nprint(letters[1:4])",
    "options": [
      "['a', 'b', 'c', 'd']",
      "['b', 'c', 'd']",
      "['b', 'c', 'd', 'e']",
      "['a', 'b', 'c']"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "List slicing [start:end] extracts elements from index start up to (but not including) index end. letters[1:4] gets indices 1, 2, and 3, which are ['b', 'c', 'd']."
  },
  {
    "question": "Complete the Python code to get the text content of a web element.",
    "code_snippet": "page_heading = driver.find_element(By.TAG_NAME, 'h1')\nheading_text = page_heading.______",
    "options": [
      "get_text()",
      "text()",
      "text",
      "inner_html"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The .text property (not a method) retrieves the visible text content of a web element. It returns the innerText, excluding HTML tags but including visible child elements' text."
  },
  {
    "question": "Which action is NOT typically performed using the ActionChains class in Selenium?",
    "options": [
      "Double-clicking an element.",
      "Navigating to a new URL.",
      "Right-clicking an element.",
      "Dragging and dropping an element."
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "ActionChains is for complex mouse and keyboard interactions (clicks, drags, hovers). Navigation (driver.get()) is a basic WebDriver method that doesn't require ActionChains."
  },
  {
    "question": "What is the result of the following Python code?",
    "code_snippet": "list_a = [1, 2, 3]\nlist_b = list_a\nlist_b.append(4)\nprint(list_a)",
    "options": [
      "[1, 2, 3]",
      "[1, 2, 3, 4]",
      "The code will raise an error because you cannot assign a list to another.",
      "[4]"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "list_b = list_a creates a reference to the same list object, not a copy. Modifying list_b also modifies list_a since they point to the same memory. Use list_a.copy() or list(list_a) to create an independent copy."
  },
  {
    "question": "Fill in the blank to navigate the browser to a specific URL.",
    "code_snippet": "from selenium import webdriver\n\ndriver = webdriver.Chrome()\ndriver.______('https://www.google.com')",
    "options": [
      "open",
      "navigate",
      "get",
      "load_page"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "driver.get('url') is the standard Selenium WebDriver method to navigate the browser to a specified URL. It waits for the page to load before continuing execution."
  },
  {
    "question": "Which pytest hook is executed before each test function runs?",
    "options": [
      "pytest_sessionstart",
      "pytest_runtest_setup",
      "pytest_runtest_teardown",
      "pytest_fixture_setup"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "pytest_runtest_setup is called before each test function executes, allowing setup actions to be performed."
  },
  {
    "question": "In automation testing, when should you prefer logging over assertions?",
    "options": [
      "When verifying critical functionality that must pass.",
      "When you need to record runtime information without stopping the test.",
      "When you want the test to fail immediately on unexpected behavior.",
      "When you are testing exception handling code."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Logging provides runtime information and context for debugging, while assertions validate conditions and fail tests if unmet."
  },
  {
    "question": "How can you run a Chrome browser in headless mode using Selenium 4?",
    "code_snippet": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\n# Missing line here\n",
    "options": [
      "options.headless = True",
      "options.set_headless(True)",
      "options.add_argument('--headless')",
      "options.run_in_background(True)"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "options.add_argument('--headless') enables Chrome to run without a GUI, ideal for CI/CD environments."
  },
  {
    "question": "What is the key difference between explicit and fluent waits in Selenium?",
    "options": [
      "Fluent waits can ignore specific exceptions and poll at intervals, while explicit waits wait for a condition up to a maximum time.",
      "Explicit waits are faster but less flexible than fluent waits.",
      "Fluent waits are deprecated in Selenium 4.",
      "There is no difference; both behave identically."
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "FluentWait allows custom polling frequency and ignored exceptions, providing more control than standard explicit waits."
  },
  {
    "question": "Which Python library is commonly used for simple REST API test automation?",
    "options": [
      "http.client",
      "urllib",
      "requests",
      "json"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "The requests library simplifies sending HTTP requests and validating API responses in test automation."
  },
  {
    "question": "What will be the output of the following Python code?",
    "code_snippet": "def multiply(a, b=2, c=3):\n    return a * b * c\n\nresult = multiply(5, c=4)\nprint(result)",
    "options": [
      "30",
      "40",
      "60",
      "The code will raise a TypeError"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "The function is called with a=5 (positional), b=2 (default), and c=4 (keyword). The result is 5 * 2 * 4 = 40."
  },
  {
    "question": "How can you handle alert pop-ups in Selenium?",
    "code_snippet": "# Assume an alert has appeared on the page\n# How to accept the alert?",
    "options": [
      "driver.accept_alert()",
      "driver.switch_to.alert.accept()",
      "driver.alert().accept()",
      "driver.handle_alert(accept=True)"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "driver.switch_to.alert switches context to the alert, and .accept() clicks the OK button. You can also use .dismiss() to cancel or .text to read the alert message."
  },
  {
    "question": "What is the purpose of a test harness in automation testing?",
    "options": [
      "A tool that generates random test data for testing purposes.",
      "A collection of software and test data configured to test a program by running it under varying conditions and monitoring its behavior.",
      "A specialized IDE for writing automated tests.",
      "A database that stores all test execution results."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "A test harness is an environment that provides the infrastructure to execute tests, including drivers, stubs, mock objects, and utilities needed to run tests systematically."
  },
  {
    "question": "What is the output of the following Python code?",
    "code_snippet": "x = [1, 2, 3]\ny = x[:]\ny.append(4)\nprint(len(x), len(y))",
    "options": [
      "3 3",
      "4 4",
      "3 4",
      "4 3"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "x[:] creates a shallow copy of the list, so y is independent of x. Appending 4 to y doesn't affect x. Therefore, x has length 3 and y has length 4."
  },
  {
    "question": "Which Selenium method allows you to get the value of an element's attribute?",
    "code_snippet": "input_field = driver.find_element(By.ID, 'username')\n# How to get the 'placeholder' attribute value?",
    "options": [
      "input_field.attribute('placeholder')",
      "input_field.get_attribute('placeholder')",
      "input_field.attr('placeholder')",
      "input_field.value_of('placeholder')"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "element.get_attribute('attribute_name') retrieves the value of any HTML attribute, such as id, class, href, value, or custom data attributes."
  },
  {
    "question": "In test-driven development (TDD), when should you write the test code?",
    "options": [
      "After implementing the feature completely.",
      "Before writing the implementation code.",
      "Only for complex features that are difficult to test manually.",
      "After the application is deployed to production."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "TDD follows the Red-Green-Refactor cycle: write a failing test first, then write code to make it pass, then refactor. This ensures code meets requirements and is testable."
  },
  {
    "question": "What will be printed by the following Python code?",
    "code_snippet": "def outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x = 20\n    inner()\n    print(x)\n\nouter()",
    "options": [
      "10",
      "20",
      "The code will raise a NameError",
      "The code will raise a SyntaxError"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "The 'nonlocal' keyword allows the inner function to modify the variable x from the enclosing outer function's scope. After inner() executes, x is changed to 20."
  },
  {
    "question": "How can you select an option from a dropdown menu in Selenium?",
    "code_snippet": "from selenium.webdriver.support.ui import Select\n\ndropdown = driver.find_element(By.ID, 'country')\n# How to select the option with visible text 'Canada'?",
    "options": [
      "dropdown.select('Canada')",
      "Select(dropdown).select_by_visible_text('Canada')",
      "dropdown.click('Canada')",
      "Select(dropdown).choose('Canada')"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "The Select class provides methods to interact with <select> elements: select_by_visible_text(), select_by_value(), and select_by_index()."
  },
  {
    "question": "What is the primary benefit of parallel test execution in automation?",
    "options": [
      "It makes tests easier to write and maintain.",
      "It reduces the overall test execution time by running multiple tests simultaneously.",
      "It automatically fixes flaky tests.",
      "It eliminates the need for test data management."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Parallel execution runs tests concurrently across multiple threads or machines, significantly reducing total execution time, especially for large test suites."
  },
  {
    "question": "What is the result of this Python code?",
    "code_snippet": "my_dict = {'a': 1, 'b': 2, 'c': 3}\nresult = {v: k for k, v in my_dict.items()}\nprint(result)",
    "options": [
      "{'a': 1, 'b': 2, 'c': 3}",
      "{1: 'a', 2: 'b', 3: 'c'}",
      "{'1': 'a', '2': 'b', '3': 'c'}",
      "The code will raise a TypeError"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Dictionary comprehension {v: k for k, v in my_dict.items()} swaps keys and values, creating a new dictionary where original values become keys."
  },
  {
    "question": "What happens if you call driver.find_element() with an invalid locator strategy in Selenium?",
    "options": [
      "It returns None",
      "It returns an empty list",
      "It raises a NoSuchElementException",
      "It raises an InvalidSelectorException"
    ],
    "correct_answer_index": 3,
    "category": "Selenium",
    "explanation": "An invalid locator (e.g., malformed XPath or CSS selector) raises InvalidSelectorException. NoSuchElementException is raised when the locator is valid but no element matches."
  },
  {
    "question": "What is continuous integration (CI) in the context of test automation?",
    "options": [
      "A practice where developers merge code changes frequently, with each merge triggering automated builds and tests.",
      "A type of integration testing performed manually by QA engineers.",
      "A deployment strategy where new features are released continuously to production.",
      "A method of integrating third-party APIs into an application."
    ],
    "correct_answer_index": 0,
    "category": "Automation",
    "explanation": "CI automates building and testing code changes frequently (often multiple times per day), catching integration issues early and providing fast feedback to developers."
  },
  {
    "question": "What will the following Python code print?",
    "code_snippet": "numbers = [1, 2, 3, 4, 5]\ntry:\n    print(numbers[10])\nexcept IndexError:\n    print('Index out of range')\nexcept Exception as e:\n    print(f'Other error: {e}')",
    "options": [
      "5",
      "None",
      "Index out of range",
      "Other error: list index out of range"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Accessing index 10 in a 5-element list raises IndexError. The first matching except block catches it and prints 'Index out of range'. More specific exceptions are caught before general ones."
  },
  {
    "question": "How do you switch back to the main page content after switching to an iframe in Selenium?",
    "options": [
      "driver.switch_to.main_content()",
      "driver.switch_to.parent_frame()",
      "driver.switch_to.default_content()",
      "driver.exit_frame()"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "driver.switch_to.default_content() switches context back to the main page. Use parent_frame() to go up one level in nested iframes, or default_content() to return to the top level."
  },
  {
    "question": "What is a test oracle in software testing?",
    "options": [
      "A database that stores expected test results.",
      "An automated tool that generates test cases.",
      "A mechanism to determine whether a test has passed or failed by comparing actual results with expected outcomes.",
      "A senior tester who reviews all test cases before execution."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "A test oracle is a source of expected results used to verify test outcomes. It can be specifications, existing systems, or domain knowledge that defines correct behavior."
  },
  {
    "question": "What is the output of this Python code?",
    "code_snippet": "class Counter:\n    count = 0\n    \n    def __init__(self):\n        Counter.count += 1\n\nc1 = Counter()\nc2 = Counter()\nc3 = Counter()\nprint(Counter.count)",
    "options": [
      "0",
      "1",
      "3",
      "The code will raise an AttributeError"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Counter.count is a class variable shared across all instances. Each time __init__ runs, it increments the shared counter. Three instances mean count becomes 3."
  },
  {
    "question": "Which method is used to maximize the browser window in Selenium?",
    "options": [
      "driver.maximize()",
      "driver.window.maximize()",
      "driver.maximize_window()",
      "driver.set_window_size('max')"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "driver.maximize_window() maximizes the browser window to fill the screen. This ensures consistent viewport size and can prevent element visibility issues in tests."
  },
  {
    "question": "What is the purpose of a mock object in unit testing?",
    "options": [
      "To test the application's performance under load.",
      "To simulate the behavior of real objects in a controlled way, allowing isolated testing of specific components.",
      "To automatically generate test data for test cases.",
      "To record all function calls made during test execution."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Mock objects simulate dependencies (databases, APIs, external services) with controlled behavior, enabling isolated unit tests without requiring actual external resources."
  },
  {
    "question": "What will this Python code output?",
    "code_snippet": "text = 'hello world'\nresult = text.split()[1].upper()\nprint(result)",
    "options": [
      "'HELLO'",
      "'WORLD'",
      "'hello world'",
      "'World'"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "text.split() splits the string into ['hello', 'world']. Index [1] gets 'world', and .upper() converts it to 'WORLD'."
  },
  {
    "question": "How can you scroll to a specific element in Selenium using JavaScript?",
    "code_snippet": "element = driver.find_element(By.ID, 'footer')\n# How to scroll to this element?",
    "options": [
      "driver.scroll_to(element)",
      "element.scroll_into_view()",
      "driver.execute_script('arguments[0].scrollIntoView();', element)",
      "ActionChains(driver).scroll_to_element(element).perform()"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "driver.execute_script('arguments[0].scrollIntoView();', element) uses JavaScript to scroll the element into the visible area of the browser window."
  },
  {
    "question": "What is the main advantage of using a keyword-driven testing framework?",
    "options": [
      "It automatically generates test data for all test cases.",
      "It allows non-technical users to create tests using predefined keywords without writing code.",
      "It makes tests run faster than other frameworks.",
      "It eliminates the need for assertions in test cases."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Keyword-driven frameworks abstract test logic into reusable keywords (actions like 'login', 'click_button'), enabling non-programmers to create tests using simple, readable syntax."
  },
  {
    "question": "What is the result of the following Python code?",
    "code_snippet": "a = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b, a is b)",
    "options": [
      "True True",
      "False False",
      "True False",
      "False True"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "== checks value equality (True, both lists contain [1, 2, 3]), while 'is' checks identity (False, they're different objects in memory)."
  },
  {
    "question": "What is the correct way to close a specific browser window in Selenium when multiple windows are open?",
    "options": [
      "driver.close()",
      "driver.quit()",
      "driver.close_window()",
      "driver.switch_to.window().close()"
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "driver.close() closes the current window/tab. driver.quit() closes all windows and ends the WebDriver session. Use window_handles to switch between windows before closing."
  },
  {
    "question": "In automation testing, what is test coverage?",
    "options": [
      "The percentage of tests that pass successfully.",
      "The number of test cases executed per hour.",
      "A measure of how much of the application code or requirements are tested by the test suite.",
      "The total time taken to execute all automated tests."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Test coverage measures the extent to which testing exercises the code (code coverage) or requirements (requirement coverage), helping identify untested areas."
  },
  {
    "question": "What will be printed by this Python code?",
    "code_snippet": "def modify_list(lst):\n    lst = lst + [4, 5]\n    return lst\n\noriginal = [1, 2, 3]\nmodified = modify_list(original)\nprint(original, modified)",
    "options": [
      "[1, 2, 3] [1, 2, 3, 4, 5]",
      "[1, 2, 3, 4, 5] [1, 2, 3, 4, 5]",
      "[1, 2, 3, 4, 5] [1, 2, 3]",
      "The code will raise a TypeError"
    ],
    "correct_answer_index": 0,
    "category": "Python",
    "explanation": "The + operator creates a new list object rather than modifying the original. The reassignment lst = lst + [4, 5] creates a new local reference, leaving 'original' unchanged."
  },
  {
    "question": "How can you get all currently open window handles in Selenium?",
    "options": [
      "driver.window_handles",
      "driver.get_windows()",
      "driver.all_windows()",
      "driver.list_handles()"
    ],
    "correct_answer_index": 0,
    "category": "Selenium",
    "explanation": "driver.window_handles returns a list of all window handle strings. You can iterate through these and use driver.switch_to.window(handle) to switch between windows."
  },
  {
    "question": "What is boundary value analysis in testing?",
    "options": [
      "Testing only the maximum values that an input can accept.",
      "A testing technique that focuses on values at the boundaries of input ranges, where errors are most likely to occur.",
      "Testing the physical boundaries of the application's user interface.",
      "A performance testing method that measures response times at the limits of system capacity."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Boundary value analysis tests values at the edges of valid ranges (min, max, just below min, just above max) where defects commonly occur due to off-by-one errors."
  },
  {
    "question": "What is the output of this Python code?",
    "code_snippet": "import copy\n\noriginal = [[1, 2], [3, 4]]\nshallow = copy.copy(original)\ndeep = copy.deepcopy(original)\n\noriginal[0][0] = 99\nprint(shallow[0][0], deep[0][0])",
    "options": [
      "1 1",
      "99 99",
      "99 1",
      "1 99"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "copy.copy() creates a shallow copy that shares nested objects. copy.deepcopy() creates independent copies of all levels. Modifying original affects shallow but not deep."
  },
  {
    "question": "In Python, what is the primary purpose of a context manager used with the 'with' statement?",
    "options": [
      "To guarantee that setup and cleanup of a resource happen reliably, even if an exception is raised",
      "To improve performance of loop execution",
      "To automatically cache function return values",
      "To force garbage collection of unused objects"
    ],
    "correct_answer_index": 0,
    "category": "Python",
    "explanation": "Context managers implement __enter__ and __exit__ to ensure deterministic acquisition and release of resources (files, locks, network connections) regardless of success or failure inside the block."
  },
  {
    "question": "Which statement best describes the difference between an iterable and an iterator in Python?",
    "options": [
      "An iterable implements __next__ only; an iterator implements __iter__ only",
      "An iterable can be looped over and provides an iterator via __iter__; an iterator produces values with __next__ until exhaustion",
      "They are identical; the terms are interchangeable",
      "Iterators must be lists; iterables must be generators"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Iterables define __iter__ returning an iterator. Iterators implement __next__ (and usually __iter__ returning self) to yield one item at a time until StopIteration."
  },
  {
    "question": "What is a key advantage of using a generator function (yield) over building a list and returning it?",
    "options": [
      "Generators automatically parallelize execution",
      "Generators allow lazy production of values, reducing memory consumption for large or infinite sequences",
      "Generators always run faster than list comprehensions",
      "Generators prevent exceptions from propagating"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Generators yield items one at a time, avoiding storing all results in memory. This is ideal for streaming, large datasets, or potentially unbounded sequences."
  },
  {
    "question": "Why is using a mutable object (e.g., []) as a default parameter generally discouraged in Python?",
    "options": [
      "It causes a syntax error",
      "The function becomes significantly slower",
      "The same object is reused across calls, leading to unintended state sharing",
      "It prevents the function from accepting keyword arguments"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Default parameter values are evaluated once at function definition time. Mutable defaults (like lists or dicts) persist changes between calls, often causing subtle bugs."
  },
  {
    "question": "What is the primary benefit of using @dataclass for simple Python classes?",
    "options": [
      "It automatically parallelizes attribute access",
      "It generates common boilerplate methods (e.g., __init__, __repr__, __eq__) based on declared fields",
      "It encrypts attribute values at runtime",
      "It forces strict static typing enforcement"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "@dataclass reduces boilerplate by auto-implementing __init__, __repr__, __eq__, and others from field definitions, improving readability and maintainability."
  },
  {
    "question": "Which built-in data structure offers O(1) average-time membership tests for unordered unique elements?",
    "options": [
      "List",
      "Tuple",
      "Set",
      "Deque"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Sets use hash-based lookup providing average O(1) membership checks, making them ideal for uniqueness and fast containment tests."
  },
  {
    "question": "What is the purpose of an __init__.py file in a Python package directory?",
    "options": [
      "To declare mandatory type hints for the package",
      "To mark the directory as a package and optionally define initialization logic or exports",
      "To improve interpreter performance when importing",
      "To disable relative imports inside the package"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "__init__.py indicates a directory is a package and can expose a public API by defining __all__ or running setup code."
  },
  {
    "question": "When iterating with index and value over a list, what is the most Pythonic approach?",
    "options": [
      "Use for i in range(0, len(items)): value = items[i]",
      "Use a while loop with manual index increment",
      "Use enumerate(items) to get (index, value) pairs directly",
      "Convert the list to a dict first"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "enumerate() yields (index, item) pairs cleanly and readably without manual index management, reducing off-by-one errors."
  },
  {
    "question": "In Selenium, what is the main difference between implicit and explicit waits?",
    "options": [
      "Implicit waits retry only click actions; explicit waits apply to navigation",
      "Implicit waits poll for all element finds up to a timeout; explicit waits target a specific condition for a specific element",
      "Explicit waits are deprecated; implicit waits are preferred",
      "There is no difference—both behave exactly the same"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "Implicit waits set a global maximum time for locating elements. Explicit waits use WebDriverWait + ExpectedConditions for fine-grained readiness checks like visibility or clickability."
  },
  {
    "question": "What is a reliable strategy for waiting on dynamic AJAX-loaded content?",
    "options": [
      "Always add a fixed time.sleep(10) before interactions",
      "Check document.readyState repeatedly with JavaScript",
      "Use an explicit wait for a stable, post-load element/state that appears only after the AJAX completes",
      "Reload the page until the element appears"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "Waiting for a deterministic element or condition (e.g., visibility of a result container) is more stable than static sleeps and avoids brittle polling hacks."
  },
  {
    "question": "What is the recommended way to upload a file using Selenium when an <input type='file'> is present?",
    "options": [
      "Drag the file onto the browser window",
      "Use ActionChains to simulate OS-level file dialogs",
      "Send the absolute file path string with send_keys() to the file input",
      "Execute JavaScript to bypass the control"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "Providing the file path via element.send_keys(path) leverages native browser handling of file inputs without interacting with OS dialogs."
  },
  {
    "question": "How can Shadow DOM elements typically be accessed in Selenium when standard locators fail?",
    "options": [
      "By using By.SHADOW directly",
      "By executing JavaScript to traverse shadowRoot and query selectors inside it",
      "By switching frames with switch_to.shadow()",
      "By enabling implicit shadow mode in capabilities"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "Selenium does not natively pierce shadow boundaries; execute_script retrieving element.shadowRoot then querySelector within is the common approach."
  },
  {
    "question": "Why is heavy reliance on brittle XPath like //div[3]/span[2] discouraged?",
    "options": [
      "It is slower than CSS by a factor of 100 always",
      "Such absolute positional XPaths often break with minor DOM changes; semantic attributes or stable IDs improve maintainability",
      "Browsers block positional XPath selectors",
      "It cannot be used in headless mode"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "Absolute or index-heavy XPaths are fragile. Prefer descriptive locators: IDs, data-* attributes, accessible labels, or relative XPath tied to stable anchors."
  },
  {
    "question": "What does the 'test pyramid' concept emphasize in automation strategy?",
    "options": [
      "Invest mostly in end-to-end UI tests and very few unit tests",
      "A broad base of fast unit tests, a middle layer of service/API tests, and a thin layer of slower UI tests",
      "Eliminate manual exploratory testing entirely",
      "Write only integration tests to reduce duplication"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "The pyramid favors many fast, reliable unit tests, fewer service-level tests, and minimal high-cost UI tests for efficiency and fast feedback."
  },
  {
    "question": "What is a primary benefit of tagging tests (e.g., @pytest.mark.slow)?",
    "options": [
      "Tags make tests run faster automatically",
      "Tags allow selective execution (e.g., skipping slow tests in quick feedback cycles)",
      "Tags enforce code coverage thresholds",
      "Tags disable retries for flaky tests"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Marking tests enables targeted subsets (fast vs slow, regression vs smoke), optimizing pipeline duration and focus."
  },
  {
    "question": "What distinguishes a mock from a stub in testing terminology?",
    "options": [
      "Mocks and stubs are identical abstractions",
      "A stub provides canned responses; a mock also records interactions for behavioral verification",
      "A stub is dynamic; a mock is static",
      "Mocks can only be used in UI tests"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Stubs supply predetermined data. Mocks add expectations/verification of method calls, arguments, and ordering to assert interactions."
  },
  {
    "question": "Which approach most effectively reduces flakiness in UI tests?",
    "options": [
      "Increase all sleeps by 5 seconds",
      "Use explicit waits and stable locators; isolate non-deterministic dependencies (network, time) with mocks where possible",
      "Retry failed tests indefinitely",
      "Run tests only on fastest hardware"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Deterministic waits plus resilient locators and isolation of variable external factors cut intermittent failures far better than arbitrary delays or blind retries."
  },
  {
    "question": "When is it a good time to refactor test code?",
    "options": [
      "Only when all production features are complete",
      "When duplication, unclear intent, or brittle patterns appear, to maintain readability and reduce maintenance cost",
      "Never—refactoring tests risks masking product defects",
      "Only after code coverage exceeds 95%"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Refactoring combats duplication and fragility, keeping the test suite sustainable and fast to evolve as the application changes."
  },
  {
    "question": "In ISTQB terminology, what is the main purpose of acceptance testing?",
    "options": [
      "To evaluate system performance under load",
      "To verify the system meets user and business needs before deployment",
      "To integrate individual components into a working system",
      "To replace the need for regression testing"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Acceptance testing checks whether the system satisfies agreed user/business requirements and is ready for operational use (e.g. User, Operational, Contract, Regulatory)."
  },
  {
    "question": "Which statement best describes 'verification' versus 'validation'?",
    "options": [
      "Verification ensures the product is built right; validation ensures the right product is built",
      "Verification is dynamic; validation is static",
      "Validation applies only to performance tests",
      "There is no formal difference in ISTQB"
    ],
    "correct_answer_index": 0,
    "category": "ISTQB",
    "explanation": "Verification: are we building the product right (conformance to specs). Validation: are we building the right product (meets user needs)."
  },
  {
    "question": "What is the primary goal of regression testing?",
    "options": [
      "To confirm new code fixes the reported defect",
      "To ensure that changes have not introduced new defects in unchanged areas",
      "To validate acceptance criteria for a new feature",
      "To stress the system at boundary conditions"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Regression testing re-executes previously run tests to detect unintended side effects after changes (defect fixes, enhancements, environment changes)."
  },
  {
    "question": "Equivalence Partitioning is BEST used to...",
    "options": [
      "Test every possible input value individually",
      "Reduce the number of test cases by grouping inputs expected to behave similarly",
      "Prove 100% absence of defects",
      "Prioritize performance-related requirements"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Equivalence Partitioning divides input (or output) domains into classes expected to be treated the same, allowing representative test values and fewer cases."
  },
  {
    "question": "Boundary Value Analysis focuses on...",
    "options": [
      "Only typical (mid-range) values",
      "Values just at, below, and above the edges of equivalence classes",
      "Random sampling within large datasets",
      "Exploratory assessment of UI usability"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "BVA targets the extremes (min, max) and just inside/outside boundaries where off-by-one defects often occur."
  },
  {
    "question": "In ISTQB terms, what is a 'failure'?",
    "options": [
      "The human error that causes a problem",
      "A deviation of the software from expected behavior during execution",
      "The root cause found in the code",
      "A missing requirement in the specification"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Failure: observable deviation during execution. Defect/Fault: the flaw in the software. Error: human action leading to a defect."
  },
  {
    "question": "Which activity is characteristic of STATIC testing?",
    "options": [
      "Executing the system with test cases",
      "Reviewing requirements documents for ambiguity",
      "Running load tests to find scalability limits",
      "Performing exploratory sessions on the deployed app"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Static testing (reviews, walkthroughs, static analysis) examines artifacts without executing code to find defects early (ambiguities, omissions, style issues)."
  },
  {
    "question": "Risk-based testing prioritizes tests based on...",
    "options": [
      "Tester preference",
      "Module size only",
      "Impact and likelihood of potential failures",
      "The number of available automation tools"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "Risk = likelihood x impact. Higher risk areas get more/earlier testing effort to reduce product and project risk."
  },
  {
    "question": "What is an exit (completion) criterion for a test level?",
    "options": [
      "A condition that triggers defect creation",
      "A set of conditions that must be satisfied to declare testing for that level finished",
      "A mandatory automation framework requirement",
      "An informal note placed in source code"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Exit criteria define when testing can conclude (e.g., % coverage achieved, defect density below threshold, all high-priority defects resolved)."
  },
  {
    "question": "Root cause analysis aims to...",
    "options": [
      "Assign blame for the defect",
      "Identify the underlying source of a problem to prevent recurrence",
      "Increase the number of logged defects",
      "Replace functional testing entirely"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Root cause analysis looks beyond the symptom to prevent future occurrences (e.g., process gaps, misunderstanding of requirements)."
  },
  {
    "question": "Which test level focuses on verifying interactions between integrated components?",
    "options": [
      "Unit Testing",
      "Integration Testing",
      "System Testing",
      "Acceptance Testing"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Integration testing validates interfaces and interactions between combined units or components before full system testing."
  },
  {
    "question": "What is a key benefit of test independence?",
    "options": [
      "Testers always find more defects than developers",
      "Reduced bias leading to more objective assessment of quality",
      "Eliminates the need for unit tests",
      "Guarantees zero defects in production"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Independent testers provide an unbiased view, increasing the chance of detecting issues developers may overlook."
  },
  {
    "question": "Which test design technique is most appropriate when business rules are expressed as combinations of conditions producing actions?",
    "options": [
      "Boundary Value Analysis",
      "Decision Table Testing",
      "State Transition Testing",
      "Use Case Testing"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Decision tables model input conditions and resulting actions, ideal for complex business rule combinations."
  },
  {
    "question": "State Transition Testing is BEST applied when...",
    "options": [
      "Inputs map to discount percentages",
      "There is navigation across independent pages only",
      "The system behavior changes based on previous events",
      "Only arithmetic calculations are performed"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "State transition testing targets systems whose output depends on prior states (e.g. login attempts, workflow progression)."
  },
  {
    "question": "Error Guessing relies primarily on...",
    "options": [
      "Formal specification coverage",
      "Tester experience and intuition",
      "Mathematical input partitioning",
      "Tool-assisted static analysis"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Error Guessing is an experience-based technique where testers anticipate likely defect areas from past patterns."
  },
  {
    "question": "Exploratory Testing is characterized by...",
    "options": [
      "Pre-scripted test cases only",
      "Simultaneous learning, test design, and execution",
      "Exclusive use of automation frameworks",
      "Formal traceability to every requirement before execution"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Exploratory testing blends learning and dynamic test design during execution to probe areas not fully specified."
  },
  {
    "question": "Which document defines the overall approach for testing across the organization or product line?",
    "options": [
      "Test Plan",
      "Test Strategy",
      "Defect Report",
      "Release Notes"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "A test strategy sets high-level principles and approaches; a test plan operationalizes these for a specific project or release."
  },
  {
    "question": "A key purpose of a Requirements Traceability Matrix (RTM) is to...",
    "options": [
      "Measure execution time of each test",
      "Map requirements to test cases ensuring coverage",
      "Rank defects by severity",
      "Eliminate redundant code paths"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Traceability matrices link requirements to design, test cases, and outcomes to demonstrate coverage and identify gaps."
  },
  {
    "question": "Which is a typical Test Closure activity?",
    "options": [
      "Defining entry criteria",
      "Designing new test cases",
      "Archiving testware and analyzing lessons learned",
      "Executing regression tests for a new sprint"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "Closure includes collecting testware, summarizing results, evaluating exit criteria, and documenting lessons learned."
  },
  {
    "question": "Alpha testing is conducted...",
    "options": [
      "Externally by end-users only",
      "Internally at the developer's site before public release",
      "After beta testing concludes",
      "Only for performance benchmarking"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Alpha testing occurs at the developer site with internal or limited external participants prior to broader beta release."
  },
  {
    "question": "Beta testing is typically performed to...",
    "options": [
      "Replace system testing",
      "Collect real-world feedback from external users in operational environments",
      "Guarantee zero known defects at release",
      "Validate unit test coverage"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Beta testing exposes the product to external users to gather usability and reliability feedback in realistic contexts."
  },
  {
    "question": "Maintenance testing is triggered MOST often by...",
    "options": [
      "Daily stand-up meetings",
      "Changes like patches, migrations, or environment updates",
      "Unit test failures only",
      "Database backups"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Maintenance testing validates that updates (defect fixes, environment upgrades, data migrations) haven't harmed existing functionality."
  },
  {
    "question": "Risk likelihood refers to...",
    "options": [
      "The severity of user impact",
      "The probability the failure will occur",
      "The number of executed test cases",
      "The cost of mitigating a defect"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Risk combines likelihood (probability of occurrence) and impact (consequence if it occurs). Both guide prioritization."
  },
  {
    "question": "Which metric helps monitor test progress effectively?",
    "options": [
      "Number of developer code commits",
      "Percentage of planned test cases executed",
      "Lines of code per module",
      "CPU utilization at runtime"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Execution progress metrics (e.g., % executed, pass/fail counts, defect discovery rate) support monitoring and control."
  },
  {
    "question": "Dynamic testing differs from static testing because it...",
    "options": [
      "Inspects artifacts without running code",
      "Executes code to observe behavior",
      "Cannot find runtime failures",
      "Requires only informal reviews"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Dynamic testing involves executing software to evaluate outcomes; static testing analyzes artifacts without execution."
  },
  {
    "question": "Decision table testing is MOST useful when...",
    "options": [
      "System response depends on multiple condition combinations",
      "Only numeric boundary conditions exist",
      "User interface layout is unstable",
      "Memory leaks must be detected"
    ],
    "correct_answer_index": 0,
    "category": "ISTQB",
    "explanation": "Decision tables clarify complex combinations of conditions and corresponding actions, supporting thorough coverage of rule sets."
  },
  {
    "question": "Pairwise (all-pairs) testing primarily reduces...",
    "options": [
      "Total combinations needing execution while retaining defect detection for interaction faults",
      "Defect severity",
      "Need for boundary tests",
      "Traceability documentation"
    ],
    "correct_answer_index": 0,
    "category": "ISTQB",
    "explanation": "Pairwise testing selects cases covering all possible pairs of parameter values, shrinking test count while exposing many interaction defects."
  },
  {
    "question": "What BEST describes regression test selection after a change?",
    "options": [
      "Retest only the modified lines",
      "Retest changed areas plus impacted functionality based on dependency analysis",
      "Skip previously passing tests",
      "Execute performance tests only"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Effective regression selection targets changed code and related areas likely influenced by the modification (data flows, interfaces)."
  },
  {
    "question": "Which is an example of a non-functional test type?",
    "options": [
      "Boundary value test",
      "Usability test",
      "Decision table test",
      "Equivalence partition test"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Non-functional testing addresses attributes like usability, performance, reliability, and security."
  },
  {
    "question": "Shift-left testing emphasizes...",
    "options": [
      "Delaying tests until after deployment",
      "Starting testing earlier in the lifecycle to detect defects sooner",
      "Only automating UI tests",
      "Removing unit tests entirely"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Shift-left moves test activities earlier (requirements/design/unit) to reduce late defect discovery costs."
  },
  {
    "question": "An INCIDENT report (defect report) typically includes...",
    "options": [
      "Future sprint capacity",
      "Steps to reproduce, observed vs expected results, and severity",
      "Complete source code diff",
      "List of all past releases"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Incident reports capture reproducible steps, environment, observed behavior, expected behavior, classification (severity/priority)."
  },
  {
    "question": "Test monitoring differs from test control by...",
    "options": [
      "Control collects status; monitoring reacts to deviations",
      "Monitoring collects status; control applies corrective actions",
      "They are identical in scope",
      "Monitoring only applies after closure"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Monitoring gathers status metrics; control uses that data to steer activities (reallocation, re-planning)."
  },
  {
    "question": "Which activity is NOT part of static testing?",
    "options": [
      "Code walkthrough",
      "Requirements review",
      "Unit test execution",
      "Design inspection"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "Static testing examines artifacts (requirements, design, code) without executing them. Unit test execution is dynamic testing."
  },
  {
    "question": "Which review type is the MOST formal and typically follows a defined entry/exit criteria with logged defects?",
    "options": [
      "Informal review",
      "Walkthrough",
      "Technical review",
      "Inspection"
    ],
    "correct_answer_index": 3,
    "category": "ISTQB",
    "explanation": "Inspections are highly formal with defined roles (moderator, reader, author, scribe), checklists, metrics, and documented defects."
  },
  {
    "question": "Which maintenance type involves adapting software to changes in its environment (e.g., new OS version)?",
    "options": [
      "Corrective maintenance",
      "Adaptive maintenance",
      "Perfective maintenance",
      "Preventive maintenance"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Adaptive maintenance modifies the product to remain usable in a changed environment (platform, regulations)."
  },
  {
    "question": "Improving performance and maintainability without adding new functionality BEST describes...",
    "options": [
      "Corrective maintenance",
      "Adaptive maintenance",
      "Perfective maintenance",
      "Emergency maintenance"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "Perfective maintenance enhances quality attributes (performance, usability, maintainability) of existing functionality."
  },
  {
    "question": "Which maintenance type aims to reduce the probability of future failures by refactoring or removing latent defects?",
    "options": [
      "Preventive maintenance",
      "Corrective maintenance",
      "Perfective maintenance",
      "Adaptive maintenance"
    ],
    "correct_answer_index": 0,
    "category": "ISTQB",
    "explanation": "Preventive maintenance anticipates issues (e.g., refactoring risky modules) to prevent future failures."
  },
  {
    "question": "Which SDLC phase typically provides the primary test basis for System Testing?",
    "options": [
      "Unit design specifications",
      "Component implementation details",
      "Requirements and functional specifications",
      "Deployment scripts"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "System testing validates the whole system against requirements, use cases, functional and non-functional specifications."
  },
  {
    "question": "Which sequence BEST represents high-level STLC (Software Testing Life Cycle) activities?",
    "options": [
      "Test planning -> Test analysis & design -> Environment setup -> Test execution -> Reporting -> Closure",
      "Test execution -> Planning -> Design -> Closure -> Analysis",
      "Design -> Closure -> Planning -> Execution",
      "Planning -> Coding -> Execution -> Release"
    ],
    "correct_answer_index": 0,
    "category": "ISTQB",
    "explanation": "Typical STLC flow: Planning, Analysis & Design, Environment/Setup, Implementation (testware), Execution, Reporting/Monitoring, Closure."
  },
  {
    "question": "Statement coverage measures...",
    "options": [
      "Percentage of decision outcomes exercised",
      "Percentage of executable statements executed",
      "Percentage of all possible paths executed",
      "Percentage of requirements traced to tests"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Statement coverage counts executed statements vs total executable statements, indicating breadth of basic code execution."
  },
  {
    "question": "Branch (decision) coverage requires...",
    "options": [
      "Each boolean sub-condition be True and False",
      "Each possible path through the code be taken",
      "Each decision (e.g., if, switch) have all outcomes executed at least once",
      "Each loop iterate maximum times"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "Branch (decision) coverage ensures every decision outcome (True/False or each case) executes at least once."
  },
  {
    "question": "Condition coverage differs from decision coverage by requiring...",
    "options": [
      "Every individual atomic condition within a decision evaluates both True and False",
      "All paths be executed",
      "No unreachable code exist",
      "All loops reach boundary values"
    ],
    "correct_answer_index": 0,
    "category": "ISTQB",
    "explanation": "Condition coverage targets each atomic boolean expression inside composite decisions separately (True & False)."
  },
  {
    "question": "Path coverage is often impractical because...",
    "options": [
      "It cannot find defects",
      "The number of paths can grow exponentially with loops and branches",
      "It ignores decisions",
      "It requires only manual testing"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Path coverage attempts to execute all distinct execution paths; loops and nested branches make paths explode combinatorially."
  },
  {
    "question": "Which coverage level conceptually subsumes statement and branch coverage?",
    "options": [
      "Condition coverage",
      "Path coverage",
      "Requirements coverage",
      "Error guessing"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "If all execution paths are covered, every statement and branch is necessarily exercised (though full path coverage is rarely feasible)."
  },
  {
    "question": "Which is the BEST example of an exit criterion?",
    "options": [
      "Start executing high priority test cases",
      "90% statement coverage achieved with all high severity defects fixed",
      "Assign testers to new features",
      "Begin defect triage meetings"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Exit criteria are conditions to conclude testing (e.g., coverage thresholds met, critical defects resolved, residual risk acceptable)."
  },
  {
    "question": "A common metric used to assess readiness against exit criteria is...",
    "options": [
      "Number of lines of code added",
      "Defect density in executed modules",
      "Developer satisfaction score",
      "Time spent in code reviews"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Defect density (defects per size unit or per function point) helps evaluate residual risk vs exit criteria thresholds."
  },
  {
    "question": "In a layered automated test strategy, which test type typically provides the fastest feedback with the highest isolation of failures?",
    "options": [
      "Unit tests",
      "End-to-end UI tests",
      "Exploratory tests",
      "User acceptance tests"
    ],
    "correct_answer_index": 0,
    "category": "Automation",
    "explanation": "Unit tests execute small, isolated code units in-memory without external dependencies, giving very fast, precise feedback on defects."
  },
  {
    "question": "What is the primary advantage of emphasizing API/service-level tests over UI tests in an automation suite?",
    "options": [
      "They require no maintenance once written",
      "They eliminate the need for any UI testing",
      "They are faster and less brittle, providing earlier detection of logic or contract defects",
      "They automatically generate complete performance metrics"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "API tests bypass fragile presentation layers, run quickly, and validate business logic and contracts early—reducing reliance on slower, brittle UI tests."
  },
  {
    "question": "In pytest, why would you use a session-scoped fixture for initializing an expensive external dependency (e.g., a Dockerized service)?",
    "options": [
      "To force each test to recreate the dependency for isolation",
      "To ensure the dependency persists across all tests, amortizing setup cost",
      "Because session scope disables teardown logic",
      "It automatically parallelizes all tests using the fixture"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Session-scoped fixtures initialize once per test session, dramatically reducing redundant costly setup while still allowing controlled teardown."
  },
  {
    "question": "Which strategy MOST effectively keeps automated test data deterministic across runs?",
    "options": [
      "Reusing and mutating shared data created by previous test executions",
      "Generating random data without any seeding policy",
      "Resetting the environment and loading a known seeded dataset before the suite starts",
      "Hardcoding dynamic identifiers directly in test scripts"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "A clean environment plus a known seeded dataset removes hidden dependencies and flakiness caused by residual or randomized state."
  },
  {
    "question": "Which of the following is a fundamental test process activity?",
    "options": [
      "Test planning and control",
      "Test implementation and execution",
      "Evaluating exit criteria and reporting",
      "All of the above"
    ],
    "correct_answer_index": 3,
    "category": "ISTQB",
    "explanation": "The fundamental test process activities include planning and control, implementation and execution, and evaluating exit criteria and reporting."
  },
  {
    "question": "What is the main purpose of static testing?",
    "options": [
      "To find defects in the code by executing it",
      "To find defects by reviewing documents like requirements, design, or code without executing it",
      "To test the system's performance under load",
      "To validate that the system meets user needs"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "The main purpose of static testing is to find defects by reviewing documents like requirements, design, or code without executing it."
  },
  {
    "question": "Which testing principle states that 'testing can show that defects are present, but cannot prove that there are no defects'?",
    "options": [
      "Exhaustive testing is impossible",
      "Defect clustering",
      "Testing is context-dependent",
      "Absence-of-errors fallacy"
    ],
    "correct_answer_index": 0,
    "category": "ISTQB",
    "explanation": "While testing can't prove the absence of defects, the Exhaustive testing is impossible principle directly addresses the inability to test all possible inputs and paths, which is why you can't prove zero defects."
  },
  {
    "question": "Which technique is a type of white-box testing?",
    "options": [
      "Equivalence Partitioning",
      "Boundary Value Analysis",
      "Decision Coverage",
      "State Transition Testing"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "Decision Coverage is a white-box testing technique that ensures each decision in the code has been executed with all possible outcomes."
  },
  {
    "question": "Which test level typically focuses on finding defects in the complete, integrated system to ensure it meets the non-functional requirements (like performance or security) and the overall system specifications?",
    "options": [
      "System Testing",
      "Integration Testing",
      "Component (Unit) Testing",
      "User Acceptance Testing"
    ],
    "correct_answer_index": 0,
    "category": "ISTQB",
    "explanation": "System testing is where you test the entire, integrated system against the system requirements specification. This is the first level where non-functional characteristics (like performance, reliability, and security) are usually formally tested."
  },
  {
    "question": "What is the primary goal of Test Control within the fundamental test process?",
    "options": [
      "To define the test approach, estimate the effort, and determine the resources needed",
      "To compare actual progress against the test plan and decide on any necessary actions to meet the objectives",
      "To specify the test conditions and design the test cases",
      "To report on the test activities and provide test summary reports"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Test Control involves monitoring the progress of testing activities, comparing actual progress against the test plan, and taking corrective actions as needed to ensure that testing objectives are met."
  },
  {
    "question": "When designing test cases using Boundary Value Analysis (BVA) for an input field that accepts values between 1 and 100 (inclusive), which of the following is the most complete set of test input values?",
    "options": [
      "1, 100",
      "0, 1, 100, 101",
      "1, 2, 99, 100",
      "0, 1, 2, 99, 100, 101"
    ],
    "correct_answer_index": 3,
    "category": "ISTQB",
    "explanation": "Boundary Value Analysis focuses on testing at the edges of input ranges. The most complete set includes values just below, at, and just above the boundaries: 0 (below lower boundary), 1 (lower boundary), 2 (just above lower boundary), 99 (just below upper boundary), 100 (upper boundary), and 101 (above upper boundary)."
  },
  {
    "question": "Which of the following describes a key objective of Integration Testing?",
    "options": [
      "To ensure the software meets the needs of the end user or customer",
      "To test interfaces between components, interactions with different parts of a system, or interactions with external systems",
      "To check that a newly modified or enhanced system still performs correctly after changes",
      "To prove the completeness of the system to the technical team before release"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Integration Testing focuses on testing the interactions between integrated components or systems. The key objective is to identify issues that may arise from these interactions, ensuring that the integrated system functions as intended."
  },
  {
    "question": "Which technique is used to measure the coverage of source code that has been tested by test cases, specifically by counting the number of executable statements that have been executed?",
    "options": [
      "Decision Coverage",
      "Statement Coverage",
      "Boundary Value Analysis",
      "Condition Coverage"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Statement Coverage is a white-box technique that measures the percentage of executable statements in the source code that have been executed by a test suite. It is the most fundamental coverage type."
  },
  {
    "question": "Which characteristic best describes the testing approach used in a Waterfall development life cycle model?",
    "options": [
      "Testing is highly iterative and occurs continuously alongside development",
      "Testing is typically planned and performed only after the development phase is fully complete",
      "Testing relies heavily on early stakeholder feedback and user stories",
      "Testing is organized around sprints and continuous integration"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Testing is typically planned and performed only after the development phase is fully complete is the characteristic that best describes the testing approach in a classic Waterfall model."
  },
  {
    "question": "When software is modified to adapt it to changes in the environment (e.g., a new operating system version or database), what type of maintenance testing is required?",
    "options": [
      "Corrective Maintenance Testing",
      "Perfective Maintenance Testing",
      "Adaptive Maintenance Testing",
      "Preventive Maintenance Testing"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "Adaptive Maintenance Testing is the type of testing required when software is modified to adapt to environmental changes."
  },
  {
    "question": "Which document is the most authoritative source for defining the expected behavior of a system during the acceptance test level?",
    "options": [
      "Test Plan",
      "System Design Specification",
      "Business Requirements Specification (BRS)",
      "User Manual"
    ],
    "correct_answer_index": 2,
    "category": "ISTQB",
    "explanation": "Business Requirements Specification (BRS) or similar document (like the User Requirements Specification) defines what the user needs and expects the system to do. Acceptance Testing is focused on validating the system against the user's needs."
  },
  {
    "question": "Which of the following is the strongest form of structural coverage (white-box) in terms of coverage achieved?",
    "options": [
      "Decision Coverage",
      "Statement Coverage",
      "Multiple Condition Coverage",
      "Path Coverage"
    ],
    "correct_answer_index": 3,
    "category": "ISTQB",
    "explanation": "Path Coverage is the strongest form of structural coverage as it requires all possible paths through the code to be executed."
  },
  {
    "question": "A test manager needs to decide where to focus limited testing resources. Two features have been identified: Feature A has a high likelihood of failure but low impact, while Feature B has a low likelihood of failure but high impact. According to risk-based testing principles, which feature should receive more testing focus?",
    "options": [
      "Feature A",
      "Feature B",
      "Both features equally",
      "Neither feature"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "Feature B should receive more testing focus because it has a higher impact, even though it has a lower likelihood of failure."
  },
  {
    "question": "An important aspect of the Test Plan is defining the Exit Criteria. Which of the following is the best example of a quantitative exit criterion?",
    "options": [
      "95% of test cases have been executed",
      "All critical defects have been fixed",
      "Test coverage meets the defined requirements",
      "All stakeholders have signed off on the test results"
    ],
    "correct_answer_index": 0,
    "category": "ISTQB",
    "explanation": "95% of test cases executed is a clear, measurable criterion for test completion."
  },
  {
    "question": "A development team performs a Technical Review on a piece of critical security code. Which role is mandatory for a formal Technical Review, as defined by ISTQB, to ensure objectivity and independence?",
    "options": [
      "The Author (Writer of the code)",
      "The Review Leader (Moderator)",
      "A Management Representative",
      "The Scribe (Recorder of defects)"
    ],
    "correct_answer_index": 1,
    "category": "ISTQB",
    "explanation": "The Review Leader/Moderator is the key role that ensures the review process maintains its formal structure, objectivity, and effectiveness."
  },
  {
    "question": "What distinguishes Continuous Delivery from Continuous Deployment in an automated pipeline?",
    "options": [
      "Continuous Delivery automatically deploys every commit straight to production",
      "Continuous Deployment requires manual packaging while Delivery skips testing",
      "Continuous Delivery ensures every change is always in a deployable state; Continuous Deployment actually releases each change automatically",
      "There is no practical difference; the terms are interchangeable"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Continuous Delivery keeps software releasable at all times with automated quality gates; Continuous Deployment takes the final step of automatically releasing each passed change to production."
  },
  {
    "question": "Fill in the blank to correctly iterate over both keys and values of the dictionary `my_dict`.",
    "code_snippet": "my_dict = {'name': 'John', 'age': 30}\nfor key, value in my_dict.______:\n    print(f'{key}: {value}')",
    "options": [
      "items()",
      "values()",
      "keys()",
      "__dict__"
    ],
    "correct_answer_index": 0,
    "category": "Python",
    "explanation": "The `.items()` method returns a view object that displays a list of a dictionary's key-value tuple pairs. This is the standard way to loop through both keys and values simultaneously in Python."
  },
  {
    "question": "Which Selenium command is used to switch the driver's context back to the main page content after operating within an iframe?",
    "options": [
      "driver.switch_to.parent_frame()",
      "driver.switch_to.main_window()",
      "driver.switch_to.default_content()",
      "driver.close_frame()"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "`driver.switch_to.default_content()` switches the focus back to the main document from an iframe or frame. `parent_frame()` only moves up one level, which may not be the main document in cases of nested frames."
  },
  {
    "question": "What is the primary advantage of data-driven testing in an automation framework?",
    "options": [
      "It makes test execution significantly faster by default.",
      "It automatically generates reports in multiple formats.",
      "It separates test logic from test data, allowing the same test script to be run with multiple datasets to increase coverage.",
      "It eliminates the need for explicit waits in tests."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Data-driven testing allows you to run a single test case with a large set of input-output data. This makes it easy to verify the application's behavior with numerous values without writing redundant test logic."
  },
  {
    "question": "Fill in the blank to complete the `try...except` block, ensuring that a specific `ValueError` is caught.",
    "code_snippet": "try:\n    age = int('twenty')\n______ ValueError as e:\n    print(f'Error: {e}')",
    "options": [
      "catch",
      "on",
      "handle",
      "except"
    ],
    "correct_answer_index": 3,
    "category": "Python",
    "explanation": "The `except` keyword is used in Python to define the block of code that handles a specific type of exception raised within the `try` block. `as e` captures the exception instance for further inspection."
  },
  {
    "question": "Complete the code to select the option with the HTML `value` attribute of 'saab' from a dropdown element.",
    "code_snippet": "from selenium.webdriver.support.ui import Select\n\ndropdown = driver.find_element(By.ID, 'cars')\nselect = Select(dropdown)\nselect.______('saab')",
    "options": [
      "select_by_name('saab')",
      "select_by_value('saab')",
      "select_by_text('saab')",
      "select_by_id('saab')"
    ],
    "correct_answer_index": 1,
    "category": "Selenium",
    "explanation": "The `Select` class in Selenium provides the `select_by_value()` method to specifically target and select an `<option>` element based on its `value` attribute, which is often a stable locator."
  },
  {
    "question": "In test automation, the 'DRY' principle is a best practice that stands for:",
    "options": [
      "Don't Run Yesterday's-tests",
      "Data-driven Reliability Yields-results",
      "Don't Repeat Yourself",
      "Do Remember Your-assertions"
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "The 'Don't Repeat Yourself' (DRY) principle aims to reduce code repetition by abstracting common parts into reusable functions or classes. This makes test suites more maintainable, readable, and less prone to errors."
  },
  {
    "question": "Which code snippet correctly removes the last element from the list `my_list` and stores it in the `last_item` variable?",
    "code_snippet": "my_list = [10, 20, 30, 40]\nlast_item = my_list.______",
    "options": [
      "pop()",
      "remove(40)",
      "get(-1)",
      "last()"
    ],
    "correct_answer_index": 0,
    "category": "Python",
    "explanation": "The `pop()` method, when called without an index, removes and returns the last item from a list. `remove(40)` would remove the value 40, but it doesn't return the item. `get()` and `last()` are not valid list methods."
  },
  {
    "question": "Which Selenium method should be used to verify if a checkbox element is currently checked?",
    "code_snippet": "checkbox = driver.find_element(By.ID, 'agree_terms')\nif checkbox.______:\n    print('Checkbox is already selected')",
    "options": [
      "is_enabled()",
      "is_displayed()",
      "is_selected()",
      "is_checked()"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The `is_selected()` method returns `True` if an element like a checkbox or radio button is selected, and `False` otherwise. It is the standard method for checking the state of such form elements."
  },
  {
    "question": "When is it more appropriate to use an API test instead of a UI test for validating application functionality?",
    "options": [
      "When testing the visual layout and CSS styling of a webpage.",
      "When the test needs to validate end-to-end user workflows exactly as a user would perform them.",
      "When you need to verify business logic on the server quickly and reliably, bypassing the slower and more brittle UI layer.",
      "When the application has no backend and runs entirely in the browser."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "API tests are significantly faster and more stable than UI tests because they interact directly with the application's business logic layer. They are ideal for validating data processing, calculations, and server responses without the overhead of rendering a UI."
  },
  {
    "question": "In test automation, what is the primary purpose of an 'integration test'?",
    "options": [
      "To test individual functions or methods in isolation.",
      "To verify that different modules or services work together as expected.",
      "To test the application's performance under heavy load.",
      "To validate the user interface and user experience."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Integration testing focuses on verifying the interactions and data flow between different components, services, or systems to ensure they function correctly when combined."
  },
  {
    "question": "What is the output of the following Python code snippet?",
    "code_snippet": "d = {'a': 1, 'b': 2}\nprint(d.get('c', 3))",
    "options": [
      "1",
      "None",
      "3",
      "KeyError"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "The `get()` method for dictionaries attempts to retrieve the value for a given key. If the key is not found, it returns the default value provided as the second argument. Here, 'c' is not in the dictionary, so it returns the default value of 3."
  },
  {
    "question": "Which of the following best describes the goal of Continuous Integration (CI) in an automation pipeline?",
    "options": [
      "To automatically deploy the application to production after every code change.",
      "To frequently merge and automatically test code changes from multiple developers to detect integration issues early.",
      "To manually test the application before each release.",
      "To write test scripts for all new features."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Continuous Integration is the practice of automating the integration of code changes from multiple contributors into a single software project. The primary goal is to run automated builds and tests to catch integration problems as quickly as possible."
  },
  {
    "question": "What is the correct way to define a function in Python that can accept any number of keyword arguments?",
    "options": [
      "def my_func(*args):",
      "def my_func(kwargs):",
      "def my_func(**kwargs):",
      "def my_func(args[]):"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "The `**kwargs` syntax in a function definition collects any keyword arguments passed to the function into a dictionary named 'kwargs'. This allows for flexible function design where the number and names of arguments are not known beforehand."
  },
  {
    "question": "What is the most effective way to handle a test that requires a unique username for each run?",
    "options": [
      "Hardcoding a list of usernames and iterating through them.",
      "Manually updating the username in the script before each execution.",
      "Using a library or function to dynamically generate a random username (e.g., with a timestamp or UUID).",
      "Reading the username from a user input prompt at the start of the test."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Dynamically generating a unique username for each test run ensures that tests are independent and repeatable without conflicts from previous runs. Hardcoding is not scalable, and manual intervention defeats the purpose of automation."
  },
  {
    "question": "How do you clear all cookies for the current domain in Selenium?",
    "options": [
      "driver.cookies.clear()",
      "driver.manage().delete_all_cookies()",
      "driver.delete_all_cookies()",
      "driver.clear_cookies()"
    ],
    "correct_answer_index": 2,
    "category": "Selenium",
    "explanation": "The `driver.delete_all_cookies()` method removes all cookies associated with the current domain, which is useful for resetting the session state before or after a test."
  },
  {
    "question": "What happens when you try to access a key that does not exist in a Python dictionary using square bracket notation (e.g., my_dict['non_existent_key'])?",
    "options": [
      "It returns None.",
      "A KeyError is raised.",
      "It returns False.",
      "An IndexError is raised."
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Accessing a dictionary key that does not exist using square bracket notation [] will raise a KeyError. The .get() method can be used to avoid this by returning a default value."
  },
  {
    "question": "What will be the output of the following code snippet?",
    "code_snippet": "def my_func(items=[]):\n items.append(1)\n print(items)\n\nmy_func()\nmy_func()",
    "options": [
      "[1]\n[1]",
      "[1]\n[1, 1]",
      "An error will be raised",
      "[1][1]\n[1][1]"
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "Python's default arguments are evaluated once when the function is defined. This means that if a mutable default argument is used and then modified, it is changed for all future calls to that function. The first call appends 1 to the list, and the second call appends 1 to the same list."
  },
  {
    "question": "Which of the following is the most Pythonic way to create a new list by applying an expression to each item in an existing list?",
    "options": [
      "Using a for loop with an append() call.",
      "Using the map() function with a lambda.",
      "Using a list comprehension.",
      "Using a while loop."
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "List comprehensions offer a more concise and readable way to create lists compared to for loops or map() functions.[13][14][15][16][17]"
  },
  {
    "question": "What is the primary purpose of the with statement in Python when working with files?",
    "options": [
      "To open a file in a special, faster mode.",
      "To automatically handle the closing of the file, even if errors occur.",
      "To provide a way to read and write to a file simultaneously.",
      "To create a temporary copy of the file."
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "The with statement uses a context manager to ensure that resources, like files, are properly managed. It automatically handles the setup and teardown, guaranteeing that a file is closed after the block is executed, even if exceptions are raised."
  },
  {
    "question": "What does the __init__ method in a Python class do?",
    "options": [
      "It is the first method that is called when a class is defined.",
      "It is a special method used to initialize an object's state when it is created.",
      "It is used to delete an object and free up memory.",
      "It returns a string representation of the object."
    ],
    "correct_answer_index": 1,
    "category": "Python",
    "explanation": "The __init__ method, often called the constructor, is automatically called when a new instance (object) of a class is created.[23][24][25][26][27] Its primary role is to initialize the attributes of the object."
  },
  {
    "question": "What is the name of the rule Python uses to search for variables?",
    "options": [
      "The Inside-Out Rule",
      "The Global-First Rule",
      "The LEGB Rule",
      "The Object-Oriented Rule"
    ],
    "correct_answer_index": 2,
    "category": "Python",
    "explanation": "Python uses the LEGB rule, which stands for Local, Enclosing, Global, and Built-in, to determine the order in which it searches for variable names.[28][29][30][31][32]"
  },
  {
    "question": "Which SOLID principle is most directly violated when a single test class is responsible for testing user authentication, profile updates, and payment processing?",
    "options": [
      "Single Responsibility Principle (SRP)",
      "Open/Closed Principle (OCP)",
      "Liskov Substitution Principle (LSP)",
      "Dependency Inversion Principle (DIP)"
    ],
    "correct_answer_index": 0,
    "category": "Automation",
    "explanation": "The Single Responsibility Principle (SRP) states that a class should have only one reason to change. Combining unrelated functionalities (authentication, profile updates, payments) into one class violates this, making the class difficult to maintain and understand."
  },
  {
    "question": "What is the primary goal of the DRY (Don't Repeat Yourself) principle in test automation?",
    "options": [
      "To ensure every test case is unique.",
      "To minimize code duplication by abstracting common actions into reusable functions or methods.",
      "To prevent the reuse of test data across different tests.",
      "To write shorter test scripts."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "DRY aims to reduce redundancy. In automation, this means creating shared methods for common sequences of actions (like logging in) so that the logic is defined in one place and can be reused across multiple test scripts, improving maintainability."
  },
  {
    "question": "In a test automation framework, what is the main benefit of using a 'Data-Driven' approach?",
    "options": [
      "It makes the tests run faster.",
      "It allows the same test logic to be executed with multiple sets of test data, improving test coverage.",
      "It automatically generates test reports.",
      "It eliminates the need for explicit waits."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "Data-driven testing separates the test logic from the test data. This allows testers to run the same test case with numerous data inputs (e.g., from a spreadsheet or database), which is highly effective for checking how the application handles different data variations."
  },
  {
    "question": "When designing an automation framework, which of the following best describes the 'Open/Closed Principle'?",
    "options": [
      "A framework should be open to extension but closed for modification.",
      "Test data should be open for anyone to read but closed for editing.",
      "Browser windows should be opened at the start of a test and closed at the end.",
      "The framework's source code should be open and publicly available."
    ],
    "correct_answer_index": 0,
    "category": "Automation",
    "explanation": "The Open/Closed Principle suggests that software entities (classes, modules, functions) should be designed so that new functionality can be added without changing the existing code. For example, adding a new page object for a new page should not require modifying the core test runner."
  },
  {
    "question": "What is the primary characteristic of a 'Behavior-Driven Development' (BDD) testing approach?",
    "options": [
      "Tests are written in a highly technical language that describes the code's implementation.",
      "Tests are written in a natural, human-readable language that describes the behavior of the application from the user's perspective.",
      "Tests are focused exclusively on the user interface and do not cover API or database interactions.",
      "Tests are written after the code has been fully developed and deployed."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "BDD uses a common language (like Gherkin's Given-When-Then syntax) that can be understood by developers, testers, and business stakeholders. This focuses the tests on the application's behavior and ensures everyone has a shared understanding of the requirements."
  },
  {
    "question": "In an automation framework, a test class directly creates a ChromeDriver instance to run a test. Which SOLID principle is most directly violated by this design?",
    "options": [
      "Open/Closed Principle",
      "Single Responsibility Principle",
      "Liskov Substitution Principle",
      "Dependency Inversion Principle"
    ],
    "correct_answer_index": 3,
    "category": "Automation",
    "explanation": "The Dependency Inversion Principle is violated because the high-level test class directly depends on a low-level concrete implementation (ChromeDriver). A better design would be to depend on an abstraction (like a generic WebDriver interface) and use a factory or dependency injection to provide the specific driver instance."
  },
  {
    "question": "What is the primary goal of the 'Test Automation Pyramid' concept?",
    "options": [
      "To have an equal number of tests at the unit, service, and UI layers.",
      "To guide teams to build a reliable and fast test portfolio by having a large base of unit tests, a smaller number of service/API tests, and the fewest end-to-end UI tests.",
      "To prioritize UI tests over all other forms of testing because they most closely mimic user behavior.",
      "To ensure that all tests are written using the same programming language."
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "The Test Pyramid is a strategy for creating a balanced test suite. It advocates for a majority of tests to be fast, stable unit tests at the bottom, with fewer, slower integration and UI tests at the top. This provides quick feedback and reduces maintenance costs."
  },
  {
    "question": "A UI test occasionally fails due to a NoSuchElementException, but passes when run again. What is the most likely cause of this 'flaky' test?",
    "options": [
      "A permanent bug in the application's user interface.",
      "Incorrect test data being used.",
      "A synchronization or timing issue, where the script tries to find an element before it has fully loaded or rendered on the page.",
      "The test runner is configured incorrectly."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Flaky tests are most often caused by race conditions between the test script and the application. The script may execute a command before the application is ready, leading to intermittent failures. This is best solved by using explicit waits (e.g., WebDriverWait) instead of fixed time.sleep() calls."
  },
  {
    "question": "Which design pattern is most appropriate for creating different WebDriver instances (e.g., Chrome, Firefox, Edge) based on a configuration parameter?",
    "options": [
      "Singleton Pattern",
      "Factory Pattern",
      "Observer Pattern",
      "Decorator Pattern"
    ],
    "correct_answer_index": 1,
    "category": "Automation",
    "explanation": "The Factory Pattern is ideal for this scenario. A 'DriverFactory' class can encapsulate the logic for creating different types of objects (WebDriver instances), so the rest of the framework does not need to know the specific details of how each driver is initialized. This makes the framework easier to extend and maintain."
  },
  {
    "question": "What does the 'Shift-Left' principle mean in the context of software testing?",
    "options": [
      "Moving all testing activities to the end of the development cycle for final validation.",
      "Shifting the primary responsibility of testing from the QA team to the development team.",
      "Starting testing activities earlier in the software development lifecycle.",
      "Automating tests from the right-to-left on the screen."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "'Shift-Left' refers to moving testing practices earlier (to the left) in the project timeline. This means integrating testing and automation from the requirements and development phases, rather than waiting until the end, in order to catch defects sooner and reduce costs."
  },
  {
    "question": "In Behavior-Driven Development (BDD), what is the primary purpose of the Gherkin syntax (Given-When-Then)?",
    "options": [
      "To serve as a detailed programming language for writing test logic.",
      "To automatically generate test data.",
      "To provide a structured, human-readable format for describing application behavior that can be understood by both technical and non-technical stakeholders.",
      "To define the architecture of the automation framework."
    ],
    "correct_answer_index": 2,
    "category": "Automation",
    "explanation": "Gherkin is designed to bridge the communication gap between business stakeholders and developers. The Given-When-Then structure allows requirements (behaviors) to be written in a clear, unambiguous way that can also serve as a skeleton for automated tests."
  },
  {
    "question": "What is the primary purpose of Artillery in software testing?",
    "options": [
      "End-to-end functional testing",
      "Unit testing individual functions",
      "Load testing and performance testing of backend services",
      "Static code analysis"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "Artillery is a modern, powerful load testing toolkit used to simulate thousands of users to test the performance and reliability of applications and APIs."
  },
  {
    "question": "What format are Artillery test scripts primarily written in?",
    "options": [
      "JSON",
      "XML",
      "Python",
      "YAML"
    ],
    "correct_answer_index": 3,
    "category": "Artillery",
    "explanation": "Artillery test scripts are typically written in YAML because it is human-readable and easy to understand, though they can also be written in JavaScript or TypeScript."
  },
  {
    "question": "In an Artillery test script, which top-level key is used to define the user behavior and the sequence of requests?",
    "options": [
      "config",
      "scenarios",
      "phases",
      "flow"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "The 'scenarios' section defines what virtual users will do, describing the sequence of requests or actions in a user session."
  },
  {
    "question": "What is the role of phases in an Artillery test script's config section?",
    "options": [
      "To define the individual HTTP requests to be sent",
      "To specify the target URL for the test",
      "To define the duration and intensity of the load, such as how many virtual users are created over time",
      "To capture and store variables from responses"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "Load phases define how Artillery generates load by specifying how many virtual users to create over a certain duration, allowing for patterns like warming up, ramping up, and sustained peak load."
  },
  {
    "question": "How can you run an Artillery test script named load-test.yml from the command line?",
    "options": [
      "artillery load-test.yml",
      "artillery execute load-test.yml",
      "artillery run load-test.yml",
      "artillery start load-test.yml"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The artillery run command is used to execute a specified test script file."
  },
  {
    "question": "In an Artillery scenario, how can you extract a value from a JSON response to use in a subsequent request?",
    "options": [
      "Using the extract key with a CSS selector",
      "Using the capture key with a JSONPath expression",
      "Using the save key with a regex",
      "Using the store key with XPath"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "The capture option in an HTTP request allows you to parse a response body (commonly using JSONPath for JSON) and store a value in a variable for later use."
  },
  {
    "question": "What is the purpose of the processor attribute in the config section of an Artillery script?",
    "options": [
      "To specify the CPU core count for the test run",
      "To define a payload from a CSV file",
      "To load a custom JavaScript or TypeScript file for extending test logic with hooks or custom functions",
      "To format the final report output"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The config.processor attribute specifies a path to a JavaScript or TypeScript file that can contain custom logic to be used during the test, such as functions for hooks like beforeRequest or afterResponse."
  },
  {
    "question": "Which command allows you to quickly test a single URL without writing a full test script file?",
    "options": [
      "artillery test",
      "artillery single",
      "artillery url",
      "artillery quick"
    ],
    "correct_answer_index": 3,
    "category": "Artillery",
    "explanation": "The artillery quick command is designed for simple, one-off tests against an endpoint directly from the command line, without needing a YAML script."
  },
  {
    "question": "In an Artillery script, what is the purpose of the config.environments block?",
    "options": [
      "To specify which operating systems the test can run on",
      "To define different sets of configuration variables (e.g., for 'staging' vs 'production') that can be selected at runtime",
      "To list the different software environments required for the test (e.g., Node.js version)",
      "To configure the virtual user's browser environment"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "The environments block allows you to define different configurations (like target URLs or API keys) for different deployment stages. You can then choose which one to use with the -e flag when running the test."
  },
  {
    "question": "How do you make Artillery use data from a CSV file named data.csv in your scenarios?",
    "options": [
      "By using config.csv: 'data.csv'",
      "By passing --csv data.csv on the command line",
      "By setting up a payload path in the config section: config.payload.path: 'data.csv'",
      "By using the loadData function within a scenario"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The config.payload section is used to load data from external files like CSVs. Setting the path attribute makes the data available as variables for use in your request definitions."
  },
  {
    "question": "Which command is used to generate a detailed HTML report after a test run has produced a JSON output file?",
    "options": [
      "artillery html report.json",
      "artillery report report.json",
      "artillery generate-report report.json",
      "artillery parse report.json"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "After running a test with the -o flag to save the output (e.g., artillery run -o report.json my-test.yml), the artillery report command is used to convert that JSON file into an HTML report."
  },
  {
    "question": "What is the role of the weight attribute in an Artillery scenario definition?",
    "options": [
      "It sets the performance impact of the scenario.",
      "It determines the order in which scenarios are executed.",
      "It defines how frequently a scenario is chosen compared to other scenarios.",
      "It specifies the total number of times the scenario should run."
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The weight attribute allows you to control the distribution of virtual users across different scenarios. A scenario with a higher weight will be selected more often."
  },
  {
    "question": "Which of the following would you use in a custom JavaScript (processor) file to run code before a request is sent?",
    "options": [
      "beforeScenario",
      "afterResponse",
      "onRequest",
      "beforeRequest"
    ],
    "correct_answer_index": 3,
    "category": "Artillery",
    "explanation": "The beforeRequest hook is a function that can be defined in a processor file to modify a request (e.g., add dynamic headers) just before it is sent by a virtual user."
  },
  {
    "question": "What does the expect block in an Artillery HTTP request allow you to do?",
    "options": [
      "Define the expected response time for the request",
      "Assert that the response meets certain conditions, like having a specific status code or content type",
      "Specify the number of concurrent requests to expect",
      "Set expectations on the server's CPU usage"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "The expect block is used for assertions. It allows you to validate that the response is correct by checking conditions like statusCode, contentType, or properties within a JSON body."
  },
  {
    "question": "Which Artillery engine would you specify in your script's config to test a WebSocket server?",
    "options": [
      "http",
      "ws",
      "socketio",
      "websocket"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "Artillery supports multiple protocols through engines. For testing WebSocket connections, you must specify engine: 'ws' in the script's configuration."
  },
  {
    "question": "What is the main advantage of using the artillery-plugin-publish-metrics plugin?",
    "options": [
      "It publishes the final test report to a web server.",
      "It allows you to create custom metrics within your test script.",
      "It sends real-time performance metrics to observability platforms like Datadog or CloudWatch.",
      "It prints more detailed metrics to the console during the test run."
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "This plugin integrates Artillery with monitoring systems by pushing metrics in real-time, which is essential for correlating application performance with the generated load."
  },
  {
    "question": "To simulate a user pausing between actions, which flow operation should be used in an Artillery scenario?",
    "options": [
      "wait",
      "pause",
      "think",
      "delay"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The think operation is used to introduce a delay in a scenario's execution, which simulates a user's 'think time' between actions, making the load test more realistic."
  },
  {
    "question": "How do you define a POST request with a JSON payload in an Artillery scenario?",
    "options": [
      "By using the post key with a body attribute containing a stringified JSON.",
      "By using the post key with a json attribute containing a YAML object.",
      "By using the send key with a json attribute.",
      "By using the request key with method: 'POST' and a payload attribute."
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "To send a JSON payload in a POST request, you use the post key for the operation and provide the data as a YAML object under the json attribute. Artillery automatically sets the Content-Type header to application/json."
  },
  {
    "question": "Which command-line flag allows you to dynamically override the target URL defined in a test script?",
    "options": [
      "--url",
      "--host",
      "--target",
      "--override-target"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The --target flag can be used with the artillery run command to override the config.target value specified in the YAML script, which is useful for running the same test against different environments without changing the file."
  },
  {
    "question": "In a load phase definition, what is the key difference between arrivalRate and rampTo?",
    "options": [
      "arrivalRate defines a constant number of new virtual users per second, while rampTo specifies a linear increase to a target arrival rate over the phase's duration.",
      "rampTo is the total number of users for the phase, while arrivalRate is how fast they are created.",
      "arrivalRate is used for warm-ups and rampTo is used for peak load.",
      "There is no difference; they are aliases for the same function."
    ],
    "correct_answer_index": 0,
    "category": "Artillery",
    "explanation": "A phase with just arrivalRate maintains a steady load. When rampTo is added, Artillery starts at the arrivalRate and linearly increases the number of new virtual users per second until it reaches the rampTo value at the end of the phase's duration."
  },
  {
    "question": "How can you repeat a series of requests multiple times for a single virtual user within a scenario?",
    "options": [
      "By using a repeat block with a times attribute.",
      "By defining the requests in a separate scenario and calling it multiple times.",
      "By using a loop block containing the requests and specifying a count.",
      "By setting a scenario.iterations property in the config."
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The loop construct in a scenario's flow allows you to repeat a block of actions. The count attribute specifies how many times the loop should execute for each virtual user."
  },
  {
    "question": "What is the primary function of the artillery-plugin-expect plugin?",
    "options": [
      "To send test metrics to external monitoring services.",
      "To generate more detailed HTML reports.",
      "To enable functional testing by adding assertions and expectations to requests.",
      "To allow for more complex load phase configurations."
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The artillery-plugin-expect extends Artillery's capabilities to include functional testing by allowing you to define expectations, such as a specific statusCode or contentType, for each request."
  },
  {
    "question": "In an Artillery summary report, what does the metric http.codes.200 represent?",
    "options": [
      "The average response time for requests with a 200 status code.",
      "The total number of virtual users that received a 200 status code.",
      "The total count of HTTP responses that returned a 200 status code during the test.",
      "The percentage of requests that were successful (status code 200)."
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "Artillery's report provides counters for different HTTP status codes received. http.codes.200 is a counter that shows the total number of requests that completed successfully with a 200 OK status."
  },
  {
    "question": "When a script has multiple scenarios defined, how does a virtual user select which one to execute?",
    "options": [
      "It executes all scenarios sequentially in the order they are defined.",
      "It randomly picks one scenario to run and runs only that one.",
      "It executes the scenarios in a random order.",
      "Each virtual user is assigned a single scenario and will run it to completion. The distribution can be controlled with the weight attribute."
    ],
    "correct_answer_index": 3,
    "category": "Artillery",
    "explanation": "For each new virtual user, Artillery picks one scenario from the list to execute. This choice can be influenced by the weight attribute on each scenario to make some user journeys more common than others."
  },
  {
    "question": "Which config attribute is used to apply a common set of headers to every HTTP request in a test script?",
    "options": [
      "globalHeaders",
      "defaults.headers",
      "headers",
      "common.headers"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "The config.defaults.headers object is used to specify headers that Artillery will automatically add to every HTTP request defined in the scenarios."
  },
  {
    "question": "How can you view the full request and response data for debugging purposes while an Artillery script is running?",
    "options": [
      "By adding log: verbose to the script's config",
      "By using the --debug flag when running the test",
      "By setting the DEBUG environment variable to http or http:response",
      "By using the artillery monitor command"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "Setting the DEBUG environment variable (e.g., DEBUG=http artillery run ...) provides detailed logging of HTTP requests, responses, and other events, which is essential for debugging scripts."
  },
  {
    "question": "What is the purpose of the artillery-plugin-faker?",
    "options": [
      "To fake or mock API endpoints for offline testing",
      "To generate realistic, randomized test data for request payloads",
      "To simulate different network conditions like high latency",
      "To create fake performance reports"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "The artillery-plugin-faker integrates the Faker.js library, allowing you to easily generate random and realistic data (like names, emails, addresses) for your tests directly within the YAML script."
  },
  {
    "question": "In Artillery, what does the Playwright engine enable you to do?",
    "options": [
      "Test backend API performance only",
      "Load test native mobile applications",
      "Run load tests that simulate real user interactions within a web browser, capturing front-end metrics",
      "Analyze network packet captures during a test"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The Playwright engine allows Artillery to control headless browsers to simulate complex user journeys on a web application, measuring user-perceived performance and capturing metrics like Core Web Vitals."
  },
  {
    "question": "How do you access the value of a variable named userId inside a request URL or body in an Artillery script?",
    "options": [
      "$userId",
      "{{ userId }}",
      "%userId%",
      "var(userId)"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "Artillery uses the double curly brace syntax, {{ variableName }}, to substitute the value of a variable that has been defined, captured from a previous response, or loaded from a payload file."
  },
  {
    "question": "What is the primary role of the ensure setting within the config section?",
    "options": [
      "To ensure that all virtual users complete their scenarios without any network errors",
      "To define Service Level Objectives (SLOs) or performance thresholds (e.g., p99 latency < 500ms) that determine if a test run passes or fails",
      "To make sure that external payload files (CSVs) are loaded correctly before the test starts",
      "To guarantee a specific arrival rate of virtual users"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "The ensure block is used to set performance and reliability conditions. If these conditions, such as a maximum error rate or a latency percentile, are not met, Artillery will exit with a non-zero status code, which is ideal for CI/CD integration."
  },
  {
    "question": "To execute a specific request in a flow only if a variable named isLoggedIn is true, which attribute should you use?",
    "options": [
      "when: 'isLoggedIn'",
      "condition: 'isLoggedIn == true'",
      "executeIf: 'isLoggedIn'",
      "ifTrue: 'isLoggedIn'"
    ],
    "correct_answer_index": 3,
    "category": "Artillery",
    "explanation": "The ifTrue attribute allows for conditional execution of a request. The request will only be sent if the specified variable has been set and is not explicitly false."
  },
  {
    "question": "How can you set a request-specific header that overrides a default header?",
    "options": [
      "You cannot override default headers.",
      "By using a beforeRequest hook to modify the headers in JavaScript.",
      "By defining a headers object directly within the individual request block (e.g., under a get or post operation).",
      "By using the --override-headers command-line flag."
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "Headers defined at the individual request level will always take precedence over headers set in the config.defaults.headers section, allowing for specific overrides."
  },
  {
    "question": "What is the primary purpose of the afterResponse hook in a custom JavaScript processor?",
    "options": [
      "To modify the outgoing request before it is sent",
      "To stop the test run if a specific condition is met",
      "To perform custom validation on a response or capture complex variables after a request is completed",
      "To define the sequence of requests in a scenario"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "The afterResponse hook is executed after a response is received, making it the ideal place for complex logic like custom validation, logging response data, or parsing the response body to set variables for subsequent requests."
  },
  {
    "question": "To test a real-time application using the Socket.IO protocol, which engine must be specified in the scenario configuration?",
    "options": [
      "http",
      "websocket",
      "ws",
      "socketio"
    ],
    "correct_answer_index": 3,
    "category": "Artillery",
    "explanation": "Artillery has a built-in engine specifically for testing Socket.IO applications. To use it, you must set engine: socketio in the scenario configuration, which enables actions like emit."
  },
  {
    "question": "How can you record a custom counter metric named items_in_cart from a custom JavaScript function?",
    "options": [
      "ee.counter('items_in_cart', 1)",
      "ee.emit('counter', 'items_in_cart', 1)",
      "Artillery.metrics.count('items_in_cart', 1)",
      "log.metric('counter', 'items_in_cart', 1)"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "Custom metrics are sent using the EventEmitter object, which is available as an argument in hook functions. The correct syntax is ee.emit('counter', 'metric_name', value) to increment a counter."
  },
  {
    "question": "What is the function of the log action within a scenario's flow?",
    "options": [
      "To log the entire test report to a file",
      "To print the value of a scenario variable or a static message to the console during a test run for debugging",
      "To send logs to an external monitoring service",
      "To control the level of logging for the entire test run (e.g., info, debug, error)"
    ],
    "correct_answer_index": 1,
    "category": "Artillery",
    "explanation": "The log action is a simple debugging tool used within a scenario's flow to print messages or the current value of variables to the console, helping to trace the execution of a virtual user."
  },
  {
    "question": "What is a primary advantage of running Artillery tests in a distributed mode on a platform like AWS Fargate?",
    "options": [
      "It allows for testing internal services that are not publicly accessible",
      "It generates more detailed HTML reports",
      "It overcomes the resource limitations of a single machine to generate a much higher load from multiple IP addresses",
      "It automatically creates test scripts based on website traffic"
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "Distributed load testing with platforms like AWS Fargate allows you to scale horizontally, overcoming the CPU, memory, and network constraints of a single machine to simulate thousands or millions of users."
  },
  {
    "question": "In a CI/CD pipeline, what is the most important outcome of a failed assertion in an ensure block?",
    "options": [
      "The test generates a detailed HTML report of the failure.",
      "The test run is automatically retried.",
      "Artillery exits with a non-zero status code, causing the CI/CD pipeline step to fail.",
      "An email notification is sent to the development team."
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "When a condition in the ensure block is not met, Artillery exits with a non-zero exit code. CI/CD systems use this exit code to determine if the job was successful, allowing the pipeline to be stopped automatically if performance SLOs are not met."
  },
  {
    "question": "During a test run, you see a large number of errors.ETIMEDOUT in the report. What does this typically indicate?",
    "options": [
      "The test script contains a syntax error.",
      "The server is responding with HTTP 504 Gateway Timeout errors.",
      "The target server did not send a response within the configured timeout period (defaulting to 10 seconds).",
      "The Artillery test runner ran out of memory."
    ],
    "correct_answer_index": 2,
    "category": "Artillery",
    "explanation": "An ETIMEDOUT error means the request was aborted because a response was not received within the configured config.http.timeout window. This can be caused by server overload or network issues."
  },
  {
    "question": "How can you define a dynamic variable, like a timestamp, using a custom JavaScript function to be used across scenarios?",
    "options": [
      "By defining the function in the config.processor file and calling it under config.variables.",
      "By using the set-variable action within a scenario.",
      "By passing it through the --vars command-line flag.",
      "This is not possible; variables must be static or from a CSV."
    ],
    "correct_answer_index": 0,
    "category": "Artillery",
    "explanation": "You can export a function from a processor file and then invoke it in the config.variables section to dynamically generate a value that can be used as a variable in your scenarios."
  },
  {
    "question": "What is the primary purpose of a BrowserContext in Playwright?",
    "options": [
      "To represent a single tab or window within a browser.",
      "To launch and manage the browser process (e.g., Chromium, Firefox).",
      "To create an isolated, incognito-like session within a single browser instance, with its own cookies and cache.",
      "To execute JavaScript code in the page."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "A BrowserContext is an isolated session within a browser instance. Each context has its own pages, cookies, and local storage, making it perfect for running independent tests in parallel without interference."
  },
  {
    "question": "Given the following Playwright code, what text will the input field with the ID 'my-input' contain after execution?",
    "code_snippet": "input_element = page.locator('#my-input')\ninput_element.fill('initial text')\ninput_element.fill('final text')",
    "options": [
      "initial text",
      "initial textfinal text",
      "final text",
      "The code will raise an error"
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "The fill() method in Playwright clears the existing content of an input field before typing the new value. Therefore, 'initial text' is completely replaced by 'final text'."
  },
  {
    "question": "Which of the following Playwright methods automatically waits for an element to be actionable (e.g., visible, enabled, and stable) before performing the action?",
    "options": [
      "page.locator()",
      "page.click()",
      "page.wait_for_selector()",
      "page.evaluate()"
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "Playwright's action methods like click(), fill(), and press() have a built-in auto-waiting mechanism. They wait for the target element to pass a series of actionability checks before executing, which eliminates the need for most explicit waits."
  },
  {
    "question": "What is the most recommended and resilient way to locate a submit button in Playwright?",
    "options": [
      "page.locator('//button[text()='Submit']')",
      "page.locator('.submit-button-class')",
      "page.get_by_role('button', name='Submit')",
      "page.locator('#submit-btn-123')"
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "page.get_by_role() is the most resilient locator because it targets elements based on how users and accessibility tools perceive them. It is less likely to break due to changes in CSS classes, IDs, or element structure compared to other locators."
  },
  {
    "question": "How do you correctly assert that an element is visible using Playwright's built-in assertion library?",
    "options": [
      "assert page.locator('#my-element').is_visible()",
      "expect(page.locator('#my-element')).to_be_visible()",
      "assertTrue(page.locator('#my-element').is_visible())",
      "verify.visible(page.locator('#my-element'))"
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "The expect() function provides auto-retrying assertions that wait for a condition to be met within a timeout. expect(locator).to_be_visible() is the idiomatic and most reliable way to assert visibility in a Playwright test."
  },
  {
    "question": "What is the purpose of the Playwright Codegen tool?",
    "options": [
      "To compile Playwright tests into a faster, executable format.",
      "To analyze and report on code quality and test coverage.",
      "To record user interactions with a web page and automatically generate a corresponding Playwright script.",
      "To manage and install browser binaries (Chromium, Firefox, WebKit)."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "Playwright Codegen is an interactive tool that records your actions in a browser and translates them into a runnable Playwright script in various languages, significantly speeding up the initial test creation process."
  },
  {
    "question": "How can you significantly speed up page loading in Playwright by preventing unnecessary network requests?",
    "options": [
      "By increasing the page load timeout value.",
      "By using page.route() to intercept and abort requests for resources like images, stylesheets, and fonts.",
      "By launching the browser in headless mode.",
      "By disabling JavaScript on the page."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "The page.route() method allows you to intercept network requests. You can create a handler that checks the resource type (e.g., 'image', 'stylesheet') or URL and calls route.abort() to prevent it from loading, which saves bandwidth and time."
  },
  {
    "question": "What information does the Playwright Trace Viewer provide for debugging tests?",
    "options": [
      "Only a video recording of the test execution.",
      "A simple pass/fail log with error messages.",
      "A detailed performance report of the host machine.",
      "A complete trace of the test, including action snapshots, network logs, console messages, and a DOM snapshot for each step."
    ],
    "correct_answer_index": 3,
    "category": "Playwright",
    "explanation": "The Trace Viewer is a powerful debugging tool that captures a detailed trace of a test run. It allows you to step through each action, inspect the DOM before and after, view network requests, and see console logs, providing a comprehensive view to diagnose failures."
  },
  {
    "question": "In Playwright, what is the correct way to handle a new page or tab that is opened after clicking a link?",
    "options": [
      "Manually switching to the new window by its handle or title.",
      "Using page.context.pages[-1] to get the last opened page.",
      "Using a context manager like with page.context.expect_page() as new_page_info: around the action that opens the new tab.",
      "Playwright automatically switches focus to the new tab, so no special handling is needed."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "The expect_page() event listener is the most reliable way to capture a new page object. It waits for a 'page' event to be emitted within the browser context during the execution of the code inside the with block, preventing race conditions."
  },
  {
    "question": "Besides browser automation, what other testing capability is built into Playwright?",
    "options": [
      "Load and performance testing.",
      "Mobile application testing for native apps.",
      "Making direct HTTP requests for API testing.",
      "Visual regression testing with automatic baseline management."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "Playwright includes an APIRequestContext object that allows you to make HTTP(S) requests directly from your test script. This is useful for testing an application's REST API, setting up server-side state before a UI test, or validating backend changes after a UI action."
  },
  {
    "question": "What is the most efficient way to handle login authentication that needs to be performed once before an entire suite of test files is run?",
    "options": [
      "Placing the login logic in a beforeEach hook within each test file.",
      "Creating a separate test file named login.spec.ts that runs first.",
      "Using a global setup file defined in playwright.config.ts to log in and save the authentication state.",
      "Manually logging in before running the test command from the terminal."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "The global setup feature allows you to run a script that performs a single, suite-wide setup. By logging in and saving the state using page.context.storage_state(), all subsequent tests can reuse the session, completely bypassing the UI login and dramatically speeding up the test suite."
  },
  {
    "question": "How do you configure a test to emulate the viewport and user agent of a mobile device like a 'Pixel 5'?",
    "options": [
      "By manually calling page.set_viewport_size() and setting a custom user-agent header.",
      "It is not possible to emulate specific mobile devices.",
      "By using the devices import from Playwright and spreading it into a new context: browser.new_context(**devices['Pixel 5']).",
      "By passing a command-line flag like --device=\"Pixel 5\" when running the tests."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "Playwright includes a devices dictionary with predefined configurations for many common devices. Using the spread operator (**) is the idiomatic and most accurate way to apply all device-specific properties (viewport, user agent, touch support, etc.) to a browser context."
  },
  {
    "question": "What is the correct and most reliable pattern to wait for and save a file that is downloaded after a click action?",
    "options": [
      "Click the download button and then use time.sleep(10) to wait for the download to finish.",
      "Intercept the download request with page.route() and manually save the response body.",
      "Wrap the click action with with page.expect_download() as download_info: and then use download = download_info.value.",
      "Continuously check the file system in a loop until the file appears."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "The page.expect_download() context manager is the canonical way to handle downloads. It listens for the download event to be triggered by the action inside the with block, avoiding race conditions and providing a Download object to interact with the file."
  },
  {
    "question": "Where should you define the default browser, headless mode, and viewport settings to be applied to all tests in a project?",
    "options": [
      "At the top of each individual test file.",
      "In a separate .env file.",
      "In the use section of the playwright.config.ts file.",
      "These settings can only be passed as command-line arguments."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "The playwright.config.ts file is the central point for configuring the test runner. The use object within this file is where you define shared options like browserName, headless, viewport, and screenshot settings that will be applied globally to all test projects."
  },
  {
    "question": "By default, how does the Playwright test runner achieve speed and efficiency when running a large number of test files?",
    "options": [
      "It runs all test files sequentially in a single browser window.",
      "It runs test files in parallel, with each file executing in an independent worker process.",
      "It runs all tests from all files together in a single shared browser context.",
      "It requires a paid license to unlock parallel execution."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "Playwright is built for modern multi-core processors and achieves high performance by running test files in parallel out-of-the-box. It creates worker processes, ensuring tests are fully isolated and do not share state, which prevents interference and maximizes speed."
  },
  {
    "question": "In a Playwright test, how can you intercept a specific API call (e.g., to /api/user) and provide a fake or 'mocked' JSON response?",
    "options": [
      "By using page.evaluate() to replace the global fetch function.",
      "By using page.add_init_script() to inject a script that modifies the API response.",
      "This is not possible; Playwright can only interact with the rendered DOM.",
      "By using page.route('/api/user', lambda route: route.fulfill(json={'name': 'Test User'}))."
    ],
    "correct_answer_index": 3,
    "category": "Playwright",
    "explanation": "page.route() is the dedicated method for intercepting network requests. It allows you to inspect the request and decide whether to abort it, continue it, or, in this case, fulfill it with a completely custom response, which is essential for testing various backend scenarios without a live API."
  },
  {
    "question": "What is the primary function of the assertion expect(page).to_have_screenshot('landing.png')?",
    "options": [
      "It takes a screenshot of the page and saves it as landing.png if the file doesn't already exist.",
      "It checks if a file named landing.png has been downloaded during the test.",
      "It performs a visual regression test by taking a screenshot and comparing it pixel-by-pixel to a previously approved 'golden' snapshot named landing.png.",
      "It asserts that the page's title contains the text 'landing.png'."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "Playwright has built-in visual comparison capabilities. to_have_screenshot() is used to prevent unintended visual changes. On its first run, it creates a snapshot; on subsequent runs, it compares the current page view to that snapshot and fails if they don't match."
  },
  {
    "question": "What is the most effective way to locate and click the 'Edit' button for a table row that contains the unique text 'Product-ABC'?",
    "options": [
      "Using a complex XPath like //tr[contains(., 'Product-ABC')]//button[text()='Edit']",
      "Using CSS selectors like tr:has-text('Product-ABC') .edit-button",
      "By chaining built-in locators: page.get_by_role('row', name='Product-ABC').get_by_role('button', name='Edit')",
      "Getting all rows with page.locator('tr').all() and looping through them to find the correct one."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "Chaining user-facing locators like get_by_role is the most resilient and readable approach. It clearly expresses the intent—find a row by its name/content, then find a button within that row by its name. This is less brittle to DOM structure changes than XPath or CSS."
  },
  {
    "question": "How do you configure Playwright to automatically retry each failing test up to 2 times before marking it as 'failed'?",
    "options": [
      "By adding a try...except block inside every test.",
      "By setting retries: 2 in the main use section or a specific project in playwright.config.ts.",
      "By running the test command with a flag like npx playwright test --retries=2.",
      "This must be configured manually using a custom test runner script."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "Playwright has built-in test retry logic to handle flaky tests. The number of retries is configured declaratively in the playwright.config.ts file. Setting retries: 2 means a test will run a total of 3 times (1 initial attempt + 2 retries) if it fails."
  },
  {
    "question": "After performing a login in a global-setup.ts file, what is the correct method to save the browser's authentication state (cookies, local storage) to a file?",
    "options": [
      "Manually copying the browser profile directory.",
      "Using page.context().storage_state(path='auth.json').",
      "Taking a screenshot of the logged-in page.",
      "Executing a script JSON.stringify(localStorage) and saving the output."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "The storage_state() method is designed specifically for this purpose. It serializes the context's session cookies and local storage into a JSON file. This file can then be used by the storageState configuration option to instantly restore a logged-in state for all tests, bypassing the need to log in repeatedly."
  },
  {
    "question": "What is the primary benefit of creating a custom test fixture in Playwright Test?",
    "options": [
      "To run tests in a specific order.",
      "To group multiple assertions into a single function.",
      "To encapsulate and reuse setup logic (like logging in or setting up API contexts), making tests cleaner and more maintainable.",
      "To automatically generate test data."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "Fixtures are the cornerstone of the Playwright Test runner for managing test setup. Creating a custom fixture (e.g., an loggedInPage fixture) allows you to isolate complex setup logic, which can then be injected into any test that needs it, promoting reusability and significantly improving test readability."
  },
  {
    "question": "What is the purpose of adding await page.pause() in a Playwright script?",
    "options": [
      "It adds a fixed 10-second delay to wait for elements to load.",
      "It stops the test execution and opens the Playwright Inspector, allowing for interactive debugging.",
      "It gracefully stops the browser and ends the test run.",
      "It captures a performance trace of the page."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "page.pause() is a powerful debugging tool. When the script reaches this line, it halts execution and launches the Playwright Inspector in a browser window. This allows you to explore the page's DOM, test out different locators, and step through the rest of your script one command at a time."
  },
  {
    "question": "Playwright's default behavior for actionability locators (e.g., locator.click()) is 'strict'. What does this mean?",
    "options": [
      "The locator must match an element that is visible, otherwise it will fail.",
      "The locator must resolve to exactly one element on the page; if it matches zero or more than one, the test will fail.",
      "The test will only run in browsers that adhere to strict web standards.",
      "The locator must be a valid CSS selector and cannot be an XPath."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "Strict mode is a core principle in Playwright that prevents test flakiness. If an action is attempted on a locator that matches multiple elements, Playwright throws an error instead of guessing which one to act upon. This forces the developer to write unambiguous, more reliable locators."
  },
  {
    "question": "How do you correctly configure a Playwright project in playwright.config.ts to run tests on multiple browsers, such as Chromium, Firefox, and WebKit, in a single command?",
    "options": [
      "By defining a separate configuration file for each browser.",
      "By passing a list of browsers to the command line, like npx playwright test --browser=chromium,firefox,webkit.",
      "By creating multiple configuration objects within the projects array, where each object specifies a different browserName.",
      "By creating a single project and setting browserName: ['chromium', 'firefox', 'webkit']."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "The projects array in the configuration file is the standard way to define cross-browser test suites. Playwright's test runner will then execute all tests against each project configuration defined in the array, allowing for robust parallel, cross-browser testing with a single command."
  },
  {
    "question": "Which code snippet correctly annotates a test to be skipped only when run against the WebKit browser?",
    "options": [
      "test.skip('my webkit test', ...);",
      "test('my test', async ({ page, browserName }) => { test.skip(browserName === 'webkit', 'Reason for skipping'); /* ... test logic ... / });",
      "test('my test', async ({ page }) => { if ('webkit') { test.skip(); } / ... test logic ... */ });",
      "// SKIP_WEBKIT\ntest('my test', ...);"
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "Playwright Test provides conditional skipping by passing a boolean expression as the first argument to test.skip(). The test runner evaluates this expression before execution; if true, the test is skipped. This is the idiomatic way to handle tests that are not applicable to specific configurations or browsers."
  },
  {
    "question": "What is the most reliable way to interact with an element inside an iframe using Playwright?",
    "options": [
      "By switching the main context of the page to the iframe before locating the element.",
      "By using page.frame_locator() to create a locator that is scoped to the iframe's DOM.",
      "By getting the iframe's contentDocument with page.evaluate() and then searching within it.",
      "By using a complex XPath that navigates across the document boundary into the iframe."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "page.frame_locator() is the dedicated, modern approach for handling iframes. It creates a locator that automatically targets the frame's content, allowing you to use standard locators like get_by_role within it. This method fully supports Playwright's auto-waiting and is more resilient than manual context switching or complex XPaths."
  },
  {
    "question": "In a Playwright test, what is the difference between a standard expect() and expect.soft() assertion?",
    "options": [
      "expect.soft() assertions are ignored completely and do not affect the test outcome.",
      "expect.soft() assertions will not terminate the test immediately upon failure; the test continues, and all failures are reported at the end.",
      "expect.soft() is used for assertions that have a longer timeout than standard assertions.",
      "expect.soft() performs a partial or 'fuzzy' match instead of a strict comparison."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "A standard expect() is a 'hard' assertion that stops the test execution on the first failure. expect.soft() creates a 'soft' assertion, which allows the test to continue running even if the check fails. This is useful for validating multiple UI properties in a single step, as it will report all failures from that step instead of just the first one."
  },
  {
    "question": "How can you simulate a slow 3G network connection for your test to verify how your page behaves under poor network conditions?",
    "options": [
      "By adding time.sleep() calls throughout the test script.",
      "This is not possible; network speed cannot be controlled by Playwright.",
      "By passing the --slow-3g flag when launching the browser.",
      "By using browser.new_context() with the offline option set to true and then using page.route() to selectively allow traffic.",
      "By using playwright.devices and selecting a device profile that includes network throttling, or by using the set_offline and emulate_network_conditions methods on a CDPSession."
    ],
    "correct_answer_index": 3,
    "category": "Playwright",
    "explanation": "Playwright provides powerful network control features. The recommended approach is to use page.route() to intercept and modify network requests, or to use the Chrome DevTools Protocol (CDP) session to emulate specific network conditions like latency and throughput, which is more realistic than static waits."
  },
  {
    "question": "How can you tag a test with '@smoke' and then run only the tests that have this tag?",
    "options": [
      "By creating a test.smoke() function.",
      "By adding the string '@smoke' to the test's title and running npx playwright test --grep \"@smoke\".",
      "By using a special comment // @tag: smoke above the test function.",
      "By defining a smoke array in the playwright.config.ts file that lists the smoke tests."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "Playwright Test uses a simple and powerful convention for tagging. By including a tag like '@smoke', '@regression', or '@sprint-5' in the test title, you can use the --grep (or -g) command-line flag with a regular expression to filter which tests to run, making it easy to execute different test suites."
  },
  {
    "question": "Given an <input type=\"file\"> element, what is the correct method to programmatically select a file for upload?",
    "options": [
      ".click() and then using a third-party library to handle the native OS file picker.",
      ".fill('C:\\path\\to\\file.txt')",
      ".press('Enter') after focusing the element.",
      ".set_input_files('path/to/file.txt')"
    ],
    "correct_answer_index": 3,
    "category": "Playwright",
    "explanation": "Playwright is designed to avoid interaction with native OS dialogs for improved reliability. The locator.set_input_files() method is the correct way to handle file uploads. It directly sets the necessary files on the input element, making the test script fast and robust."
  },
  {
    "question": "In a test scenario where you must first create data via a POST request to /api/items before interacting with it in the UI, what is the most robust and idiomatic Playwright approach?",
    "options": [
      "Use page.goto() to navigate to the API endpoint and send a POST request.",
      "Use page.evaluate() to run a fetch() call from the browser's context.",
      "Use the separate request fixture that comes with @playwright/test to make a direct, authenticated API call independent of the page.",
      "Create a hidden <form> element on the page, fill it with data, and submit it using Playwright."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "The request fixture provides a dedicated APIRequestContext for making direct server-side API calls. This is far more efficient and reliable than trying to script API interactions through the UI (evaluate, goto), as it bypasses the browser entirely and can share authentication state with your UI tests."
  },
  {
    "question": "A test fails intermittently on a CI/CD pipeline due to a timeout, but it always passes on your local machine. What is the most effective configuration change in playwright.config.ts to debug this type of issue?",
    "options": [
      "Significantly increasing the global timeout value.",
      "Setting headless: false to watch the test run in the CI environment.",
      "Setting the trace option to 'on-first-retry' or 'retain-on-failure'.",
      "Increasing the number of retries to 5 or more."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "While increasing retries or timeouts might make the test pass, it doesn't solve the underlying problem. Enabling tracing ('on-first-retry' is ideal) will capture a full trace of the failed run, including DOM snapshots, network requests, and console logs, which you can then download and analyze locally to find the root cause of the flakiness."
  },
  {
    "question": "What is the best practice for designing a reusable Page Object Model (POM) class, for example, a LoginPage, in Playwright?",
    "options": [
      "The class constructor should create its own browser instance to ensure it is isolated.",
      "The class should contain hardcoded locators and methods that perform actions, and it should be instantiated with new LoginPage() in the test.",
      "The class constructor should accept the page fixture as an argument, and its methods should use this page object to interact with elements.",
      "The class should extend playwright.Page and use super() to initialize."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "The standard and most effective pattern is to use dependency injection. The test file's page fixture, which is managed by the test runner, is passed into the Page Object's constructor. This ensures the POM class acts on the correct page state without needing to manage browser contexts itself, making it highly reusable and easy to integrate with fixtures."
  },
  {
    "question": "You need to run a test that validates a search feature with five different search terms. What is the most common and readable way to parameterize this test in Playwright Test?",
    "options": [
      "Create five separate test files, one for each search term.",
      "Use test.describe.parallel() to create a suite for each term.",
      "Create a single test and use test.step() for each different search term.",
      "Create an array of search terms and loop through it using a standard for...of loop, with the test() function defined inside the loop."
    ],
    "correct_answer_index": 3,
    "category": "Playwright",
    "explanation": "Playwright Test dynamically generates tests from loops. Placing a test() block inside a for loop is the recommended, idiomatic way to achieve parameterization. The test runner will recognize this and create a distinct test for each item in the array, which can run in parallel and will be reported on individually."
  },
  {
    "question": "What is the key difference between page.wait_for_load_state('domcontentloaded') and page.wait_for_load_state('networkidle')?",
    "options": [
      "domcontentloaded is faster, while networkidle is more reliable.",
      "domcontentloaded waits until the HTML is parsed, while networkidle waits until there have been no new network connections for a short period, which is useful for single-page applications (SPAs).",
      "domcontentloaded is for static sites, and networkidle is for dynamic sites.",
      "There is no functional difference; networkidle is just an alias for domcontentloaded."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "domcontentloaded fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes. networkidle is a more robust signal for modern web apps, as it waits until the network has been quiet, indicating that dynamic data loading and rendering via JavaScript are likely complete."
  },
  {
    "question": "An element you need to interact with is located inside a Shadow DOM. Which of the following is the correct Playwright syntax to click a button within it?",
    "options": [
      "page.locator('my-component').shadow_dom().locator('button').click()",
      "page.locator('my-component >> button').click()",
      "page.evaluate('document.querySelector(\"my-component\").shadowRoot.querySelector(\"button\").click()')",
      "Playwright automatically pierces the Shadow DOM, so page.locator('button').click() will work."
    ],
    "correct_answer_index": 3,
    "category": "Playwright",
    "explanation": "Playwright's locators can seamlessly pierce both open and closed Shadow DOMs. It treats shadow boundaries as a standard part of the DOM tree, so you can chain locators or use standard CSS selectors without any special commands, making the syntax clean and consistent."
  },
  {
    "question": "While the `playwright.config.ts` sets the default viewport for all tests, you have a single test file that specifically needs to run with an iPhone 13 Pro viewport. What is the most idiomatic way to apply this setting only for that file?",
    "options": [
      "Create a separate `playwright.iphone.config.ts` file and run the test with that config.",
      "Use `test.use({ ...devices['iPhone 13 Pro'] })` at the top of the test file.",
      "Manually call `page.set_viewport_size()` at the beginning of every test within the file.",
      "Pass a command-line flag like `--viewport=iphone-13-pro` when running the specific file."
    ],
    "correct_answer_index": 1,
    "category": "Playwright",
    "explanation": "`test.use()` allows you to override or extend the global configuration at a per-file or per-describe-block level. This is the intended and cleanest way to apply specific settings (like a device viewport, different timeouts, or custom fixtures) to a subset of tests without altering the global configuration."
  },
  {
    "question": "What is the primary benefit of wrapping logical blocks of code within a test using `await test.step()`?",
    "options": [
      "It allows the test to run faster by executing steps in parallel.",
      "It provides a way to add extra timeouts for long-running operations.",
      "It improves the structure and readability of the test report, showing each step as a collapsible, timed section with its own context, making debugging failures much easier.",
      "It is the only way to create and use local variables within a test."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "The main purpose of `test.step()` is to enhance test reports. In the HTML report, each step appears as a distinct, expandable entry with its own duration and substeps (like locator actions and assertions). When a test fails, you can immediately see which logical step failed, which is invaluable for quick debugging."
  },
  {
    "question": "A button click on your page triggers a native browser `confirm` dialog. How do you ensure your test clicks 'OK' on this dialog without failing?",
    "options": [
      "Playwright automatically accepts all dialogs by default, so no extra code is needed.",
      "Use `try...except` to catch the `DialogAppeared` exception and then handle it.",
      "Register a one-time event handler with `page.once('dialog', dialog => dialog.accept())` before the action that triggers the dialog.",
      "Use `page.keyboard.press('Enter')` immediately after clicking the button."
    ],
    "correct_answer_index": 2,
    "category": "Playwright",
    "explanation": "Unhandled dialogs will cause Playwright tests to hang and fail. The correct, non-racy way to handle them is to set up a listener for the `dialog` event *before* performing the action that will open it. The `page.once()` method sets up a listener that runs just once, automatically handles the dialog as soon as it appears, and then removes itself."
  },
  {
    "question": "What is the purpose of the `page.expose_function(name, callback)` method in Playwright?",
    "options": [
      "To make a DOM element's function, like `element.click()`, available to be called directly from the test script.",
      "To run a Node.js function within the context of a web worker on the page.",
      "To define a custom Playwright command that can be used later in the script.",
      "To bind a function from the Node.js environment of the test script to the page's `window` object, allowing JavaScript running in the browser to call back into the Playwright script."
    ],
    "correct_answer_index": 3,
    "category": "Playwright",
    "explanation": "`page.expose_function` bridges the gap between the browser's sandboxed environment and the test's Node.js environment. It attaches the provided callback to `window[name]`. This is useful for advanced scenarios, such as listening for custom events fired by the application's JavaScript and acting on them within the test script."
  },
  {
    "question": "Which of the following correctly defines a variable that can hold either a string or a number in TypeScript?",
    "options": [
      "let value: string | number;",
      "let value: string & number;",
      "let value: [string, number];",
      "let value: any;"
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "The pipe symbol `|` creates a union type, which allows a variable to hold values of any of the specified types. `&` creates an intersection, `[]` creates a tuple or array, and `any` bypasses type checking entirely."
  },
  {
    "question": "What is the purpose of the `interface` keyword in TypeScript?",
    "options": [
      "To create a new class.",
      "To define the shape of an object, specifying the names and types of its properties.",
      "To create a loop construct.",
      "To handle asynchronous operations."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "An interface is a core feature in TypeScript used to define contracts or 'shapes' for objects. It ensures that objects conform to a specific structure, improving code consistency and maintainability."
  },
  {
    "question": "What will be the output of the following TypeScript code when compiled and run?",
    "code_snippet": "function greet(name?: string) {\n  console.log(`Hello, ${name?.toUpperCase() || 'Guest'}!`);\n}\ngreet();",
    "options": [
      "Hello, !",
      "An error will be thrown because name is undefined.",
      "Hello, Guest!",
      "Hello, UNDEFINED!"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "The parameter `name` is optional (`?`). Inside the function, optional chaining (`?.`) prevents an error if `name` is undefined. The nullish coalescing operator `||` provides a default value 'Guest' when `name?.toUpperCase()` results in `undefined`."
  },
  {
    "question": "Which of the following is NOT a valid access modifier for class properties in TypeScript?",
    "options": [
      "public",
      "private",
      "protected",
      "internal"
    ],
    "correct_answer_index": 3,
    "category": "Typescript",
    "explanation": "TypeScript provides `public`, `private`, and `protected` access modifiers, similar to languages like C# and Java. `internal` is not a valid access modifier in TypeScript."
  },
  {
    "question": "What is a key difference between a TypeScript `interface` and a `type` alias?",
    "options": [
      "Interfaces can be implemented by classes, while type aliases cannot.",
      "Type aliases can be used for union types and primitives, while interfaces are only for object shapes.",
      "Interfaces can be merged (declaration merging), whereas type aliases create a single, distinct type.",
      "Type aliases are checked at runtime, while interfaces are only checked at compile time."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "A significant difference is that interfaces with the same name in the same scope are automatically merged (declaration merging), which is useful for extending existing interfaces. Type aliases do not have this behavior."
  },
  {
    "question": "How do you define a tuple in TypeScript that must contain a string followed by a number?",
    "options": [
      "let myTuple: (string, number);",
      "let myTuple: {string, number};",
      "let myTuple: <string, number>;",
      "let myTuple: [string, number];"
    ],
    "correct_answer_index": 3,
    "category": "Typescript",
    "explanation": "Tuples in TypeScript use square bracket syntax `[]` to define a fixed-length array where the type of each element at a specific position is known."
  },
  {
    "question": "What does the `void` return type signify in a TypeScript function?",
    "options": [
      "The function returns a `null` or `undefined` value.",
      "The function does not return any value.",
      "The function can return a value of any type.",
      "The function is an asynchronous function."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "`void` is used to indicate that a function does not have a return statement or does not return an explicit value. While it might technically return `undefined` in JavaScript, its purpose in TypeScript is to declare the absence of a return value."
  },
  {
    "question": "What is the purpose of a Generic in TypeScript?",
    "options": [
      "To generate documentation automatically.",
      "To create reusable components or functions that can work with a variety of types.",
      "To specify the exact type of a variable.",
      "To restrict access to class members."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "Generics allow you to write functions, classes, and interfaces that are type-safe and reusable, as they can operate on different data types without sacrificing type checking."
  },
  {
    "question": "What does the `as` keyword do in TypeScript?",
    "options": [
      "It creates an alias for a module.",
      "It performs a type assertion, telling the compiler to treat a value as a different type.",
      "It is used to import a library.",
      "It declares a new variable."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "The `as` keyword is used for type assertions (also known as type casting). It's a way for the developer to override TypeScript's inferred type and provide a specific type, which can be useful when you have more information about a value's type than the compiler does."
  },
  {
    "question": "How do you mark a property in an interface as optional?",
    "options": [
      "By adding the `optional` keyword before the property name.",
      "By adding a question mark `?` after the property name.",
      "By assigning `null` as its default type.",
      "By using the `| undefined` union type."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "Appending a `?` to a property name in an interface or type alias indicates that the property is optional and does not need to be present on objects of that type."
  },
  {
    "question": "What is the `never` type used for in TypeScript?",
    "options": [
      "To represent a value that is either `null` or `undefined`.",
      "To indicate that a function will never be called.",
      "To represent the type of values that never occur, such as a function that always throws an error or has an infinite loop.",
      "To bypass all type checking for a variable."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "The `never` type represents values that will never happen. It's typically the return type for functions that always throw an exception or functions that contain an endless loop, as they never reach a return statement."
  },
  {
    "question": "Which utility type in TypeScript creates a new type by picking a set of properties from an existing type?",
    "options": [
      "Omit<T, K>",
      "Partial<T>",
      "Pick<T, K>",
      "Extract<T, U>"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "`Pick<Type, Keys>` constructs a new type by selecting only the specified `Keys` (a string literal or union of string literals) from the `Type`."
  },
  {
    "question": "What is the purpose of the `readonly` modifier in TypeScript?",
    "options": [
      "It prevents a variable from being reassigned.",
      "It marks a class property so that it can only be assigned a value during its declaration or in the constructor.",
      "It ensures a function does not have any side effects.",
      "It makes an entire object immutable."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "The `readonly` modifier is used on class properties to prevent them from being modified after their initial assignment, which must happen at declaration or within the class constructor."
  },
  {
    "question": "What does the `keyof` operator do in TypeScript?",
    "options": [
      "It returns the value of a specific key in an object.",
      "It creates a new type representing the union of public property names (keys) of a given type.",
      "It checks if an object has a specific key at runtime.",
      "It extracts the type of a property from an object type."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "The `keyof` operator takes an object type and produces a string or numeric literal union of its keys. For example, `keyof { id: number; name: string; }` results in the type `'id' | 'name'`."
  },
  {
    "question": "How can you implement an interface in a TypeScript class?",
    "options": [
      "class MyClass extends IMyInterface {}",
      "class MyClass uses IMyInterface {}",
      "class MyClass implements IMyInterface {}",
      "class MyClass of IMyInterface {}"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "The `implements` keyword is used in a class declaration to state that it will adhere to the contract defined by an interface, ensuring the class has all the properties and methods specified by that interface."
  },
  {
    "question": "What is an Enum in TypeScript?",
    "options": [
      "A way to define a set of named constants.",
      "A special type of class that cannot be instantiated.",
      "A function that returns another function.",
      "A data structure for storing key-value pairs."
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "Enums (enumerations) allow a developer to define a set of named constants, making it easier to work with a distinct set of related values, such as directions (North, South, East, West)."
  },
  {
    "question": "Which TypeScript compiler option in `tsconfig.json` ensures that you don't have variables with an implicit `any` type?",
    "options": [
      "\"strict\": true",
      "\"noImplicitAny\": true",
      "\"noAny\": true",
      "\"allowAny\": false"
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "Setting `\"noImplicitAny\": true` raises an error on expressions and declarations with an implied `any` type, forcing developers to be explicit about their types. This is also enabled by the umbrella `\"strict\": true` option."
  },
  {
    "question": "What is a type guard in TypeScript?",
    "options": [
      "A security feature to prevent malicious type injections.",
      "A compile-time check to ensure a type is used correctly.",
      "An expression that performs a runtime check to guarantee the type of a value within a certain scope.",
      "A special comment that suppresses type-checking errors."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "Type guards are runtime checks (like `typeof`, `instanceof`, or user-defined functions) that allow TypeScript to infer a more specific type for a variable within a conditional block."
  },
  {
    "question": "Which of the following creates a new type where all properties of `T` are optional?",
    "options": [
      "Optional<T>",
      "Nullable<T>",
      "Partial<T>",
      "Required<T>"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "`Partial<T>` is a built-in mapped utility type that constructs a new type by taking all properties from type `T` and marking them as optional."
  },
  {
    "question": "In the context of TypeScript modules, what is the difference between a default export and a named export?",
    "options": [
      "A module can have multiple default exports but only one named export.",
      "A module can have only one default export but multiple named exports.",
      "Default exports must be functions, while named exports can be any type.",
      "Default exports are imported with curly braces `{}`, while named exports are not."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "A module can have any number of named exports (`export const x = ...`) which are imported using their exact name in curly braces (`import { x } from './module'`). However, a module can only have one default export (`export default ...`), which can be imported with any name (`import MyDefault from './module'`)."
  },
  {
    "question": "What does the `unknown` type represent in TypeScript?",
    "options": [
      "It is a synonym for the `any` type.",
      "It represents a value that is known to be a function.",
      "It is the type-safe counterpart of `any`. You cannot perform any operations on a value of type `unknown` without first performing a type check.",
      "It is used for variables that have not yet been assigned a value."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "`unknown` is safer than `any` because it forces you to perform explicit checks (like using `typeof` or type assertions) to narrow down the type before you can operate on the value, thus preventing potential runtime errors."
  },
  {
    "question": "What is the purpose of an abstract class in TypeScript?",
    "options": [
      "To create a class that cannot be instantiated and is meant to be a base class for other classes to extend.",
      "To define a class that only contains static methods.",
      "To hide the implementation details of a class from other parts of the code.",
      "To create a simple object for data storage."
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "Abstract classes serve as blueprints for derived classes. They cannot be instantiated on their own and may contain abstract methods (methods without an implementation) that must be implemented by the derived classes."
  },
  {
    "question": "Which TypeScript feature allows for declaring class properties and initializing them from constructor parameters in a single step?",
    "options": [
      "Auto-initialization",
      "Constructor properties",
      "Parameter properties",
      "Member shorthand"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "Parameter properties let you create and initialize a member in one place. By prefixing a constructor parameter with an access modifier like `public` or `private`, TypeScript generates a property with that name and automatically assigns the parameter's value to it."
  },
  {
    "question": "What does the following generic constraint `T extends { length: number }` mean?",
    "options": [
      "The type `T` must be exactly the type `{ length: number }`.",
      "The type `T` can be any type.",
      "The type `T` must be a class that extends the `length` class.",
      "The type `T` must have a property named `length` of type `number`."
    ],
    "correct_answer_index": 3,
    "category": "Typescript",
    "explanation": "Generic constraints, using the `extends` keyword, are used to limit the types that can be passed as a type argument. In this case, it ensures that the type `T` has a `length` property of type `number`, which is common for strings and arrays."
  },
  {
    "question": "How do you define a string literal type in TypeScript?",
    "options": [
      "type Status = 'pending' | 'approved' | 'rejected';",
      "let status: String = 'pending';",
      "enum Status { 'pending', 'approved', 'rejected' }",
      "interface Status { value: 'pending' | 'approved' | 'rejected' }"
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "A string literal type restricts a variable to a specific set of strings. Using a union of string literals (`'pending' | 'approved'`) is the direct way to define this type, providing better autocompletion and error checking than a regular `string` type."
  },
  {
    "question": "What is the primary function of the `tsconfig.json` file?",
    "options": [
      "To list all the TypeScript files in a project.",
      "To define the project's dependencies, like `package.json`.",
      "To specify the root files and the compiler options required to compile a TypeScript project.",
      "To store environment variables for the project."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "The presence of a `tsconfig.json` file in a directory indicates that the directory is the root of a TypeScript project. The file specifies the compiler options (like target ECMAScript version, module system, and strictness) and the files to be included in the compilation."
  },
  {
    "question": "Which utility type constructs a type by excluding a set of properties `K` from a type `T`?",
    "options": [
      "Exclude<T, K>",
      "Pick<T, K>",
      "Required<T>",
      "Omit<T, K>"
    ],
    "correct_answer_index": 3,
    "category": "Typescript",
    "explanation": "`Omit<Type, Keys>` creates a new type by taking all properties from `Type` and then removing the specified `Keys`. It's the opposite of the `Pick` utility type."
  },
  {
    "question": "What is a Decorator in TypeScript?",
    "options": [
      "A function that modifies the behavior of a variable.",
      "A special kind of declaration that can be attached to a class declaration, method, accessor, property, or parameter.",
      "A design pattern for creating objects.",
      "A syntax for commenting code."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "Decorators are an experimental feature that provides a way to add annotations and meta-programming syntax for class declarations and members. They use the form `@expression`, where `expression` must evaluate to a function that will be called at runtime with information about the decorated declaration."
  },
  {
    "question": "What is the correct syntax for a type assertion in JSX/TSX files?",
    "options": [
      "let x = <string>myValue;",
      "let x = myValue as string;",
      "let x = string(myValue);",
      "Both `<string>myValue` and `myValue as string` work."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "In `.ts` files, both the angle-bracket syntax (`<type>value`) and the `as` syntax (`value as type`) are valid for type assertions. However, in `.tsx` files (used with React), the angle-bracket syntax conflicts with JSX's element syntax, so only the `as` syntax is allowed."
  },
  {
    "question": "What will be the inferred type of the `user` variable in the following code?",
    "code_snippet": "const user = {\n  id: 1,\n  name: 'John Doe',\n  isActive: true\n};",
    "options": [
      "`any`",
      "`{ id: number; name: string; isActive: boolean; }`",
      "`object`",
      "`Map<string, any>`"
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "TypeScript's type inference system analyzes the structure of the object literal at declaration and infers the most specific type. It identifies the property names (`id`, `name`, `isActive`) and their corresponding value types (`number`, `string`, `boolean`) to create a precise object shape."
  },
  {
    "question": "How do you specify a function type for a callback in TypeScript?",
    "options": [
      "`callback: function`",
      "`callback: Function`",
      "`callback: (error: Error | null, result: string) => void`",
      "`callback: <(error, result)>`"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "Function types are defined using an arrow-like syntax that specifies the parameter types and the return type. `(param1: type1, ...) => returnType` is the standard way to ensure type safety for callbacks and other function arguments."
  },
  {
    "question": "What does the `instanceof` operator do in the context of a TypeScript type guard?",
    "options": [
      "It checks if an object has a specific property.",
      "It verifies if an object is an instance of a particular class or constructor function.",
      "It compares two object instances to see if they are the same.",
      "It creates a new instance of a class."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "The `instanceof` operator is a JavaScript feature that TypeScript uses as a type guard. In a conditional block, if `x instanceof SomeClass` is true, TypeScript will narrow the type of `x` to `SomeClass` within that block."
  },
  {
    "question": "Which of the following utility types makes all properties of a type `T` non-optional?",
    "options": [
      "Partial<T>",
      "Readonly<T>",
      "Required<T>",
      "NonNullable<T>"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "`Required<T>` is a mapped type that constructs a new type by taking all properties from `T` and making them mandatory. It's the opposite of `Partial<T>`."
  },
  {
    "question": "What is the `target` option in `tsconfig.json` used for?",
    "options": [
      "To specify which files should be included in the compilation.",
      "To define the module system (e.g., 'CommonJS', 'ESNext').",
      "To set the ECMAScript version that the TypeScript code will be compiled down to.",
      "To enable or disable strict type-checking options."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "The `target` compiler option determines the JavaScript version of the output code (e.g., 'ES5', 'ES2015', 'ESNext'). This allows you to write modern TypeScript/JavaScript and compile it to an older version for compatibility with older browsers."
  },
  {
    "question": "In TypeScript, what is an index signature?",
    "options": [
      "A way to define the type of an array's index, which is always `number`.",
      "A way to describe the types of properties that are not known when an interface is created, allowing for dynamic property names.",
      "A special syntax for accessing array elements.",
      "A unique identifier for each type in a program."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "An index signature, like `[key: string]: any;`, is used on an interface or type to indicate that it can have additional properties beyond the explicitly defined ones. It specifies the type of the key and the type of the value for these dynamic properties."
  },
  {
    "question": "How can you ensure a generic function only accepts object types?",
    "options": [
      "function process<T extends object>(obj: T) {}",
      "function process<T is object>(obj: T) {}",
      "function process<T>(obj: T & object) {}",
      "function process<T>(obj: object) {}"
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "Using a generic constraint `T extends object` ensures that the function is generic (preserving the specific type of the input `T`) while also requiring that `T` be assignable to the `object` type. This is more specific than simply typing the argument as `object`."
  },
  {
    "question": "What does a mapped type like `{ [P in K]: T }` do in TypeScript?",
    "options": [
      "It creates a map data structure.",
      "It iterates over the keys `K` and creates a new object type where each key `P` has the type `T`.",
      "It defines a function that maps keys to values.",
      "It is an invalid syntax in TypeScript."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "Mapped types are a powerful feature that allows the creation of new types based on the properties of an existing type. The syntax `[P in K]` iterates through a union of keys `K` (often from `keyof T`) to define the properties of the new type."
  },
  {
    "question": "Which of the following is true about TypeScript compared to JavaScript?",
    "options": [
      "TypeScript code can be executed directly by all modern browsers without any compilation.",
      "TypeScript adds optional static typing and other features that are compiled away to produce JavaScript.",
      "TypeScript is a completely different language and has no relationship with JavaScript.",
      "JavaScript has a more advanced type system than TypeScript."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "TypeScript is a superset of JavaScript, meaning any valid JavaScript is valid TypeScript. It adds a static type system on top of JavaScript, which helps catch errors during development. This TypeScript code must be compiled (transpiled) into standard JavaScript to run in browsers."
  },
  {
    "question": "What is the purpose of the `as const` assertion?",
    "options": [
      "To declare a variable as a constant, similar to the `const` keyword.",
      "To tell the compiler to infer the most specific, literal, and readonly type possible for an object or array.",
      "To cast a value to a constant expression.",
      "To prevent a value from being modified at runtime."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "`as const` provides a way to treat expressions as literals. For an object, it makes all properties `readonly`. For a string, it infers the literal type (e.g., `'hello'`) instead of the general `string` type. This is useful for creating fixed, immutable data structures."
  },
  {
    "question": "What is a conditional type in TypeScript?",
    "options": [
      "A type that depends on a runtime condition.",
      "A type that can be either `true` or `false`.",
      "A type that is chosen from two possible types based on a static type relationship, using a syntax like `T extends U ? X : Y`.",
      "An if-else statement for types that executes during compilation."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "Conditional types allow for type-level logic. They check a condition (`T extends U`) at compile time and select one of two types (`X` or `Y`) based on the outcome, enabling advanced type manipulations."
  },
  {
    "question": "What does the `NonNullable<T>` utility type do?",
    "options": [
      "It ensures that a value is not an empty string.",
      "It constructs a type by excluding `null` and `undefined` from `T`.",
      "It checks if a value is not zero.",
      "It converts a nullable type into a string representation."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "`NonNullable<T>` is a conditional utility type that creates a new type by removing `null` and `undefined` from the set of possible types in `T`. For example, `NonNullable<string | null | undefined>` results in `string`."
  },
  {
    "question": "What is the correct way to define an array of strings in TypeScript?",
    "options": [
      "let list: Array<string>;",
      "let list: string[];",
      "Both A and B are correct.",
      "let list: {string};"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "TypeScript offers two equivalent syntaxes for defining arrays: `string[]` and the generic array type `Array<string>`. Both are functionally identical and the choice between them is a matter of coding style."
  },
  {
    "question": "What happens if you try to assign a number to a variable typed as `string` in TypeScript?",
    "options": [
      "The number will be automatically converted to a string at runtime.",
      "A compile-time error will be thrown.",
      "A runtime error will occur when the code is executed.",
      "TypeScript will automatically change the variable's type to `number`."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "The primary purpose of TypeScript's static type system is to catch type mismatches during development. Assigning a value of the wrong type to a variable will result in an error when you try to compile the code, preventing the bug from ever reaching runtime."
  },
  {
    "question": "What is declaration merging in TypeScript?",
    "options": [
      "The process of combining multiple variable declarations into one.",
      "The compiler's ability to merge multiple `interface` declarations with the same name into a single definition.",
      "A feature that combines all TypeScript files into a single output file.",
      "A way to merge two different types into a new one."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "If you define an interface with the same name more than once in the same scope, TypeScript's compiler will merge their members into a single, combined interface. This is particularly useful for extending third-party library types."
  },
  {
    "question": "What is the `this` keyword's behavior in an arrow function in TypeScript?",
    "options": [
      "It refers to the global object (e.g., `window`).",
      "It is always `undefined`.",
      "It captures the `this` value of the enclosing context where the function was created.",
      "It refers to the object that called the function."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "This behavior is inherited from JavaScript. Unlike regular functions, arrow functions do not have their own `this` binding. Instead, they lexically capture the `this` from their surrounding scope, which avoids common bugs and the need for `.bind(this)`."
  },
  {
    "question": "How do you define default values for function parameters in TypeScript?",
    "options": [
      "function greet(name: string = 'Guest') {}",
      "function greet(name: string | 'Guest') {}",
      "function greet(name?: string = 'Guest') {}",
      "function greet(name: string default 'Guest') {}"
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "TypeScript uses the same syntax as modern JavaScript for default-initialized parameters. You provide an initializer (`= 'Guest'`) after the type annotation. A parameter with a default value is automatically considered optional."
  },
  {
    "question": "What does the `typeof` type guard do?",
    "options": [
      "It returns a string representing the type of a variable at compile time.",
      "It performs a runtime check on the type of a variable and allows the TypeScript compiler to infer a more specific type within a block.",
      "It is used to create a new type alias.",
      "It checks if a type is defined in the current scope."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "The `typeof` operator, when used in a conditional statement (e.g., `if (typeof myVar === 'string')`), acts as a type guard. Inside that block, TypeScript knows that `myVar` is a `string`, allowing you to use string-specific methods without a compiler error."
  },
  {
    "question": "Which of these is a valid use case for the `any` type?",
    "options": [
      "For all variables to make coding faster.",
      "When migrating a legacy JavaScript project to TypeScript and you need a temporary solution.",
      "When a value's type is truly unknown and cannot be represented by other types.",
      "When working with third-party libraries that don't have type definitions."
    ],
    "correct_answer_index": 3,
    "category": "Typescript",
    "explanation": "While `any` should be avoided because it sacrifices type safety, it is a necessary escape hatch when interacting with untyped JavaScript libraries or dynamically structured data where the type cannot be statically known. For unknown values, the `unknown` type is now preferred over `any`."
  },
  {
    "question": "How do you define a static property in a TypeScript class?",
    "options": [
      "By using the `static` keyword before the property name.",
      "By defining the property outside the class body.",
      "By using the `@static` decorator.",
      "All properties are static by default."
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "The `static` keyword is used to declare properties or methods that belong to the class itself, rather than to an instance of the class. They are accessed directly from the class, such as `MyClass.myStaticProperty`."
  },
  {
    "question": "Which of the following is the correct way to get the return type of a function type `T`?",
    "options": [
      "ReturnType<T>",
      "T.returnType",
      "GetReturnType<T>",
      "T.prototype.return"
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "`ReturnType<T>` is a built-in conditional utility type. It takes a function type `T` and produces its return type. This is useful for advanced type manipulation and creating types based on existing function signatures."
  },
   {
    "question": "What is the primary purpose of a declaration file (e.g., `index.d.ts`) in TypeScript?",
    "options": [
      "To store the compiled JavaScript output.",
      "To define project-specific environment variables.",
      "To contain the implementation logic for a module.",
      "To provide type information for JavaScript code, allowing TypeScript to understand its shape."
    ],
    "correct_answer_index": 3,
    "category": "Typescript",
    "explanation": "Declaration files (`.d.ts`) contain ambient declarations, which describe the types of existing JavaScript libraries or modules. They provide a way for the TypeScript compiler to perform type checking and offer autocompletion for code that was not originally written in TypeScript."
  },
  {
    "question": "What is a discriminated union (or tagged union) in TypeScript?",
    "options": [
      "A union type that can only hold string or number values.",
      "A technique where objects in a union share a common literal property (the discriminant) that is used to narrow down the type.",
      "A union that automatically filters out `null` and `undefined` values.",
      "A special type of union that can only be used in `if-else` statements."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "Discriminated unions are a powerful pattern for working with union types. By having a common property with a literal type (e.g., `type: 'success'` vs `type: 'error'`), you can use a `switch` statement or `if` checks on that property to safely and correctly narrow the object's type within each block."
  },
  {
    "question": "What is the key difference between the `unknown` and `any` types?",
    "options": [
      "`unknown` can only be used for objects, while `any` can be used for any value.",
      "They are functionally identical and can be used interchangeably.",
      "`any` allows you to perform any operation on it without type checking, while `unknown` forces you to perform a type check or assertion before operations are allowed.",
      "Variables of type `unknown` cannot be reassigned, unlike variables of type `any`."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "`unknown` is the type-safe counterpart to `any`. It represents a value whose type is not known, but unlike `any`, it prevents you from performing potentially unsafe operations until you have explicitly narrowed the type using a type guard (like `typeof` or `instanceof`)."
  },
  {
    "question": "How does the `in` operator work as a type guard in TypeScript?",
    "options": [
      "It checks if a value exists within an array.",
      "It checks if a property name exists in an object, and if true, narrows the object's type to one that includes that property.",
      "It is used to iterate through the keys of an object in a `for` loop.",
      "It verifies that a type is part of a union type."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "When used in a conditional block like `if ('propertyName' in object)`, the `in` operator performs a runtime check for the property's existence. TypeScript uses this check to intelligently narrow the type of the `object` variable within that block to a type that is known to have `propertyName`."
  },
  {
    "question": "What is the purpose of the `satisfies` operator introduced in TypeScript 4.9?",
    "options": [
      "It is a new syntax for creating an interface.",
      "It forces a variable to be immutable.",
      "It is a runtime function to check if an object meets certain criteria.",
      "It validates that an expression conforms to a type without changing the inferred type of the expression itself."
    ],
    "correct_answer_index": 3,
    "category": "Typescript",
    "explanation": "The `satisfies` operator allows you to ensure an object's structure is compatible with a given type while preserving the specific literal types of its properties. This is different from a type annotation (`: Type`), which can sometimes cause the compiler to lose more specific type information in favor of the broader annotation."
  },
  {
    "question": "Within a conditional type, what does the `infer` keyword allow you to do?",
    "options": [
      "To let the compiler infer the type of the entire conditional type.",
      "To dynamically introduce a new type variable that represents a type captured from within the checked type.",
      "To create an intersection type.",
      "To force the conditional type to evaluate to `any`."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "`infer` is an advanced feature used inside the `extends` clause of a conditional type. It lets you capture a part of a type. For example, in `type UnpackPromise<T> = T extends Promise<infer U> ? U : T;`, `infer U` captures the type that the Promise resolves to, allowing you to create a new type `U` from it."
  },
  {
    "question": "What is an assertion function in TypeScript?",
    "options": [
      "A function that always returns a boolean value.",
      "A function that uses the `asserts` keyword to signal that it will throw an error if a condition is not met, allowing the compiler to narrow types for the rest of the code block.",
      "A synonym for a type guard.",
      "A function that can only be used in test files."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "An assertion function, defined with a signature like `assert(condition): asserts condition`, does not return a value. Instead, it checks a condition and throws an error if it's false. If the function completes without throwing, the TypeScript compiler understands that the asserted condition must be true for all subsequent code, effectively acting as a powerful type guard."
  },
  {
    "question": "What is the inferred type of the `user` variable in the following code?",
    "code_snippet": "const user = {\n  id: 1,\n  name: 'John Doe',\n  isAdmin: false\n};",
    "options": [
      "any",
      "object",
      "{ id: any; name: any; isAdmin: any; }",
      "{ id: number; name: string; isAdmin: boolean; }"
    ],
    "correct_answer_index": 3,
    "category": "Typescript",
    "explanation": "TypeScript's type inference engine analyzes the properties and their initial values to create the most specific object type. It correctly identifies `id` as a `number`, `name` as a `string`, and `isAdmin` as a `boolean`."
  },
  {
    "question": "What will be logged to the console when this TypeScript code is executed?",
    "code_snippet": "function process(input: string | null) {\n  const value = input ?? 'default';\n  console.log(value.toUpperCase());\n}\nprocess(null);",
    "options": [
      "An error will be thrown",
      "NULL",
      "DEFAULT",
      "undefined"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "The nullish coalescing operator (`??`) returns the right-hand side operand (`'default'`) when the left-hand side is `null` or `undefined`. Therefore, `value` becomes `'default'`, and `toUpperCase()` is called on it, logging 'DEFAULT'."
  },
  {
    "question": "Given the `User` interface, why does the following code fail to compile?",
    "code_snippet": "interface User {\n  name: string;\n  age: number;\n}\nconst user: User = {\n  name: 'Jane Doe'\n};",
    "options": [
      "The `name` property is missing.",
      "The `user` variable should be a `let` instead of a `const`.",
      "The `age` property is missing from the object literal.",
      "The interface is not implemented correctly."
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "The `User` interface defines a contract that requires both `name` (a string) and `age` (a number) to be present. The object being assigned to the `user` variable is missing the `age` property, which results in a compile-time error."
  },
  {
    "question": "What is the resulting type of `UserPreview`?",
    "code_snippet": "interface User {\n  id: number;\n  name: string;\n  email: string;\n  lastLogin: Date;\n}\n\ntype UserPreview = Omit<User, 'email' | 'lastLogin'>;",
    "options": [
      "{ id: number; name: string; }",
      "{ email: string; lastLogin: Date; }",
      "id | name",
      "The code will cause a syntax error."
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "The `Omit<T, K>` utility type constructs a new type by taking all properties from `T` and then removing the keys specified in `K`. In this case, it removes `email` and `lastLogin` from the `User` type, leaving only `id` and `name`."
  },
  {
    "question": "What is the value of `Direction.Right` in this enum?",
    "code_snippet": "enum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right\n}",
    "options": [
      "0",
      "3",
      "4",
      "\"Right\""
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "Numeric enums in TypeScript auto-increment from the previous value. Since `Up` is explicitly set to `1`, `Down` becomes `2`, `Left` becomes `3`, and `Right` becomes `4`."
  },
  {
    "question": "What is the inferred return type of the `createPair` function?",
    "code_snippet": "function createPair<S, T>(v1: S, v2: T) {\n  return [v1, v2];\n}",
    "options": [
      "any[]",
      "(S | T)[]",
      "[S, T]",
      "Array<any>"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "TypeScript infers the return type as a tuple `[S, T]` because it knows the array will always have exactly two elements, with the type of the first element being `S` and the second being `T`. This is more specific than a general array type like `(S | T)[]`."
  },
  {
    "question": "What will this code log to the console?",
    "code_snippet": "type User = {\n  name: string;\n  profile?: {\n    photoUrl: string;\n  }\n}\n\nconst user: User = { name: 'Bob' };\nconsole.log(user.profile?.photoUrl);",
    "options": [
      "A TypeError at runtime",
      "null",
      "An empty string \"\"",
      "undefined"
    ],
    "correct_answer_index": 3,
    "category": "Typescript",
    "explanation": "Optional chaining (`?.`) is used to safely access nested properties. If `user.profile` is `null` or `undefined`, the expression short-circuits and evaluates to `undefined` instead of throwing an error. Since `user` has no `profile` property, the result is `undefined`."
  },
  {
    "question": "What is the type of `ReadonlyUser`?",
    "code_snippet": "interface User {\n  name: string;\n  age: number;\n}\n\ntype ReadonlyUser = Readonly<User>;",
    "options": [
      "It is an error because User is an interface.",
      "{ readonly name: string; readonly age: number; }",
      "The same as `User`, but its properties cannot be changed at runtime.",
      "A class with private setters for `name` and `age`."
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "The `Readonly<T>` utility type constructs a new type where all properties of `T` are marked as `readonly`. This means you cannot reassign these properties after the object has been created, which will be enforced at compile time."
  },
  {
    "question": "What does this function log to the console?",
    "code_snippet": "function checkValue(value: string | number) {\n  if (typeof value === 'number') {\n    console.log(value.toFixed(2));\n  } else {\n    console.log(value.trim());\n  }\n}\ncheckValue('  hello  ');",
    "options": [
      "An error, because `value` could be a number",
      "  hello  ",
      "hello",
      "0.00"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "The `typeof value === 'number'` check acts as a type guard. Since the input is `'  hello  '`, the condition is false, and the code enters the `else` block. Inside this block, TypeScript knows that `value` must be a `string`, so calling `value.trim()` is safe and logs 'hello'."
  },
  {
    "question": "What is the type of `PointKeys`?",
    "code_snippet": "type Point = {\n  x: number;\n  y: number;\n};\n\ntype PointKeys = keyof Point;",
    "options": [
      "string",
      "\"x\" | \"y\"",
      "number",
      "any"
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "The `keyof` operator takes an object type and produces a string or numeric literal union of its keys. For the `Point` type, this results in a union of its property names, which is `'x' | 'y'`."
  },
  {
    "question": "What is the output of this code?",
    "code_snippet": "const data = { value: 0 };\nconst display = data.value ?? 'N/A';\nconsole.log(display);",
    "options": [
      "0",
      "\"N/A\"",
      "null",
      "true"
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "The nullish coalescing operator (`??`) only provides the default value if the left-hand side is `null` or `undefined`. Since `data.value` is `0` (a falsy but not nullish value), the operator returns the left-hand side value, which is `0`."
  },
  {
    "question": "Which of these function calls is valid, based on the provided overloads?",
    "code_snippet": "function format(input: string): string;\nfunction format(input: number): string;\nfunction format(input: string | number): string {\n  if (typeof input === 'number') {\n    return `Value: ${input}`;\n  }\n  return input.trim();\n}\n",
    "options": [
      "format(true)",
      "format(['hello'])",
      "format(123)",
      "format(null)"
    ],
    "correct_answer_index": 2,
    "category": "Typescript",
    "explanation": "TypeScript uses the overload signatures (the first two lines) to perform type checking. It sees that `format` can be called with either a `string` or a `number`. The call `format(123)` matches the second overload signature, `function format(input: number): string;`, and is therefore valid."
  },
  {
    "question": "What is the type of `HttpMethod` after this code snippet?",
    "code_snippet": "const req = {\n  method: 'POST',\n  url: '/api/users'\n} as const;\n\ntype HttpMethod = typeof req.method;",
    "options": [
      "string",
      "'POST'",
      "any",
      "const"
    ],
    "correct_answer_index": 1,
    "category": "Typescript",
    "explanation": "The `as const` assertion tells TypeScript to infer the most specific, literal type possible. For `req.method`, instead of inferring the general type `string`, it infers the literal type `'POST'`. Therefore, `HttpMethod` becomes the type that can only be the string `'POST'`."
  },
  {
    "question": "What is the type of `Result`?",
    "code_snippet": "type Unpack<T> = T extends (infer U)[] ? U : T;\ntype Result = Unpack<boolean[]>;",
    "options": [
      "boolean",
      "boolean[]",
      "U",
      "unknown"
    ],
    "correct_answer_index": 0,
    "category": "Typescript",
    "explanation": "This is a conditional type. The condition `T extends (infer U)[]` checks if `T` is an array. If it is, the `infer U` keyword captures the element type of the array into a new type variable `U`. Since `boolean[]` is an array of booleans, `U` is inferred as `boolean`, which becomes the resulting type."
  }
]